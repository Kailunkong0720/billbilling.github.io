<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0054)http://www.monmouth.com/~wstreett/lex-yacc/flex_1.html -->
<HTML><HEAD><TITLE>flex</TITLE>
<META http-equiv=Content-Type content="text/html; charset=gb2312">
<META content="MSHTML 6.00.2800.1561" name=GENERATOR></HEAD>
<BODY>
<UL></UL>
<H2>NAME </H2>
<UL>flex - fast lexical analyzer generator </UL>
<H2>SYNOPSIS </H2>
<UL><B>flex</B> <B>[-bcdfhilnpstvwBFILTV78+?</B> <B>-C[aefFmr]</B> 
  <B>-ooutput</B> <B>-Pprefix</B> <B>-Sskeleton]</B> <B>[--help</B> 
  <B>--version]</B> <I>[filename</I> <I>...]</I> </UL>
<H2>OVERVIEW </H2>
<UL>This manual describes <I>flex,</I> a tool for generating programs that 
  perform pattern-matching on text. The manual includes both tutorial and 
  reference sections: <PRE>
<P><BR>    Description
<BR>        a brief overview of the tool
<BR>
<P><BR>    Some Simple Examples
<BR>
<P><BR>    Format Of The Input File
<BR>
<P><BR>    Patterns
<BR>        the extended regular expressions used by flex
<BR>
<P><BR>    How The Input Is Matched
<BR>        the rules for determining what has been matched
<BR>
<P><BR>    Actions
<BR>        how to specify what to do when a pattern is matched
<BR>
<P><BR>    The Generated Scanner
<BR>        details regarding the scanner that flex produces;
<BR>        how to control the input source
<BR>
<P><BR>    Start Conditions
<BR>        introducing context into your scanners, and
<BR>        managing "mini-scanners"
<BR>
<P><BR>    Multiple Input Buffers
<BR>        how to manipulate multiple input sources; how to
<BR>        scan from strings instead of files
<BR>
<P><BR>    End-of-file Rules
<BR>        special rules for matching the end of the input
<BR>
<P><BR>    Miscellaneous Macros
<BR>        a summary of macros available to the actions
<BR>
<P><BR>    Values Available To The User
<BR>        a summary of values available to the actions
<BR>
<P><BR>    Interfacing With Yacc
<BR>        connecting flex scanners together with yacc parsers
<BR>
<P><BR>    Options
<BR>        flex command-line options, and the "%option"
<BR>        directive
<BR>
<P><BR>    Performance Considerations
<BR>        how to make your scanner go as fast as possible
<BR>
<P><BR>    Generating C++ Scanners
<BR>        the (experimental) facility for generating C++
<BR>        scanner classes
<BR>
<P><BR>    Incompatibilities With Lex And POSIX
<BR>        how flex differs from AT&amp;T lex and the POSIX lex
<BR>        standard
<BR>
<P><BR>    Diagnostics
<BR>        those error messages produced by flex (or scanners
<BR>        it generates) whose meanings might not be apparent
<BR>
<P><BR>    Files
<BR>        files used by flex
<BR>
<P><BR>    Deficiencies / Bugs
<BR>        known problems with flex
<BR>
<P><BR>    See Also
<BR>        other documentation, related tools
<BR>
<P><BR>    Author
<BR>        includes contact information
<BR>
<P><BR></P></PRE></UL>
<H2>DESCRIPTION </H2>
<UL><I>flex</I> is a tool for generating <I>scanners:</I> programs which 
  recognized lexical patterns in text. <I>flex</I> reads the given input files, 
  or its standard input if no file names are given, for a description of a 
  scanner to generate. The description is in the form of pairs of regular 
  expressions and C code, called <I>rules.</I> <I>flex</I> generates as output a 
  C source file, <B>lex.yy.c,</B> which defines a routine <B>yylex().</B> This 
  file is compiled and linked with the <B>-lfl</B> library to produce an 
  executable. When the executable is run, it analyzes its input for occurrences 
  of the regular expressions. Whenever it finds one, it executes the 
  corresponding C code. </UL>
<H2>SOME SIMPLE EXAMPLES </H2>
<UL>
  <P>First some simple examples to get the flavor of how one uses <I>flex.</I> 
  The following <I>flex</I> input specifies a scanner which whenever it 
  encounters the string "username" will replace it with the user's login name: <PRE>
<P><BR>    %%
<BR>    username    printf( "%s", getlogin() );
<BR>
<P><BR></P></PRE>By default, any text not matched by a <I>flex</I> scanner is 
  copied to the output, so the net effect of this scanner is to copy its input 
  file to its output with each occurrence of "username" expanded. In this input, 
  there is just one rule. "username" is the <I>pattern</I> and the "printf" is 
  the <I>action.</I> The "%%" marks the beginning of the rules. 
  <P>Here's another simple example: <PRE>
<P><BR>            int num_lines = 0, num_chars = 0;
<BR>
<P><BR>    %%
<BR>    \n      ++num_lines; ++num_chars;
<BR>    .       ++num_chars;
<BR>
<P><BR>    %%
<BR>    main()
<BR>            {
<BR>            yylex();
<BR>            printf( "# of lines = %d, # of chars = %d\n",
<BR>                    num_lines, num_chars );
<BR>            }
<BR>
<P><BR></P></PRE>This scanner counts the number of characters and the number 
  of lines in its input (it produces no output other than the final report on 
  the counts). The first line declares two globals, "num_lines" and "num_chars", 
  which are accessible both inside <B>yylex()</B> and in the <B>main()</B> 
  routine declared after the second "%%". There are two rules, one which matches 
  a newline ("\n") and increments both the line count and the character count, 
  and one which matches any character other than a newline (indicated by the "." 
  regular expression). 
  <P>A somewhat more complicated example: <PRE>
<P><BR>    /* scanner for a toy Pascal-like language */
<BR>
<P><BR>    %{
<BR>    /* need this for the call to atof() below */
<BR>    #include &lt;math.h&gt;
<BR>    %}
<BR>
<P><BR>    DIGIT    [0-9]
<BR>    ID       [a-z][a-z0-9]*
<BR>
<P><BR>    %%
<BR>
<P><BR>    {DIGIT}+    {
<BR>                printf( "An integer: %s (%d)\n", yytext,
<BR>                        atoi( yytext ) );
<BR>                }
<BR>
<P><BR>    {DIGIT}+"."{DIGIT}*        {
<BR>                printf( "A float: %s (%g)\n", yytext,
<BR>                        atof( yytext ) );
<BR>                }
<BR>
<P><BR>    if|then|begin|end|procedure|function        {
<BR>                printf( "A keyword: %s\n", yytext );
<BR>                }
<BR>
<P><BR>    {ID}        printf( "An identifier: %s\n", yytext );
<BR>
<P><BR>    "+"|"-"|"*"|"/"   printf( "An operator: %s\n", yytext );
<BR>
<P><BR>    "{"[^}\n]*"}"     /* eat up one-line comments */
<BR>
<P><BR>    [ \t\n]+          /* eat up whitespace */
<BR>
<P><BR>    .           printf( "Unrecognized character: %s\n", yytext );
<BR>
<P><BR>    %%
<BR>
<P><BR>    main( argc, argv )
<BR>    int argc;
<BR>    char **argv;
<BR>        {
<BR>        ++argv, --argc;  /* skip over program name */
<BR>        if ( argc &gt; 0 )
<BR>                yyin = fopen( argv[0], "r" );
<BR>        else
<BR>                yyin = stdin;
<BR>        
<BR>        yylex();
<BR>        }
<BR>
<P><BR></P></PRE>This is the beginnings of a simple scanner for a language 
  like Pascal. It identifies different types of <I>tokens</I> and reports on 
  what it has seen. 
  <P>The details of this example will be explained in the following sections. 
  </P></UL>
<H2>FORMAT OF THE INPUT FILE </H2>
<UL>The <I>flex</I> input file consists of three sections, separated by a line 
  with just <B>%%</B> in it: <PRE>
<P><BR>    definitions
<BR>    %%
<BR>    rules
<BR>    %%
<BR>    user code
<BR>
<P><BR></P></PRE>The <I>definitions</I> section contains declarations of 
  simple <I>name</I> definitions to simplify the scanner specification, and 
  declarations of <I>start</I> <I>conditions,</I> which are explained in a later 
  section. 
  <P>Name definitions have the form: <PRE>
<P><BR>    name definition
<BR>
<P><BR></P></PRE>The "name" is a word beginning with a letter or an underscore 
  ('_') followed by zero or more letters, digits, '_', or '-' (dash). The 
  definition is taken to begin at the first non-white-space character following 
  the name and continuing to the end of the line. The definition can 
  subsequently be referred to using "{name}", which will expand to 
  "(definition)". For example, <PRE>
<P><BR>    DIGIT    [0-9]
<BR>    ID       [a-z][a-z0-9]*
<BR>
<P><BR></P></PRE>defines "DIGIT" to be a regular expression which matches a 
  single digit, and "ID" to be a regular expression which matches a letter 
  followed by zero-or-more letters-or-digits. A subsequent reference to <PRE>
<P><BR>    {DIGIT}+"."{DIGIT}*
<BR>
<P><BR></P></PRE>is identical to <PRE>
<P><BR>    ([0-9])+"."([0-9])*
<BR>
<P><BR></P></PRE>and matches one-or-more digits followed by a '.' followed by 
  zero-or-more digits. 
  <P>The <I>rules</I> section of the <I>flex</I> input contains a series of 
  rules of the form: <PRE>
<P><BR>    pattern   action
<BR>
<P><BR></P></PRE>where the pattern must be unindented and the action must 
  begin on the same line. 
  <P>See below for a further description of patterns and actions. 
  <P>Finally, the user code section is simply copied to <B>lex.yy.c</B> 
  verbatim. It is used for companion routines which call or are called by the 
  scanner. The presence of this section is optional; if it is missing, the 
  second <B>%%</B> in the input file may be skipped, too. 
  <P>In the definitions and rules sections, any <I>indented</I> text or text 
  enclosed in <B>%{</B> and <B>%}</B> is copied verbatim to the output (with the 
  %{}'s removed). The %{}'s must appear unindented on lines by themselves. 
  <P>In the rules section, any indented or %{} text appearing before the first 
  rule may be used to declare variables which are local to the scanning routine 
  and (after the declarations) code which is to be executed whenever the 
  scanning routine is entered. Other indented or %{} text in the rule section is 
  still copied to the output, but its meaning is not well-defined and it may 
  well cause compile-time errors (this feature is present for <I>POSIX</I> 
  compliance; see below for other such features). 
  <P>In the definitions section (but not in the rules section), an unindented 
  comment (i.e., a line beginning with "/*") is also copied verbatim to the 
  output up to the next "*/". </P></UL>
<H2>PATTERNS </H2>
<UL>The patterns in the input are written using an extended set of regular 
  expressions. These are: <PRE>
<P><BR>    x          match the character 'x'
<BR>    .          any character (byte) except newline
<BR>    [xyz]      a "character class"; in this case, the pattern
<BR>                 matches either an 'x', a 'y', or a 'z'
<BR>    [abj-oZ]   a "character class" with a range in it; matches
<BR>                 an 'a', a 'b', any letter from 'j' through 'o',
<BR>                 or a 'Z'
<BR>    [^A-Z]     a "negated character class", i.e., any character
<BR>                 but those in the class.  In this case, any
<BR>                 character EXCEPT an uppercase letter.
<BR>    [^A-Z\n]   any character EXCEPT an uppercase letter or
<BR>                 a newline
<BR>    r*         zero or more r's, where r is any regular expression
<BR>    r+         one or more r's
<BR>    r?         zero or one r's (that is, "an optional r")
<BR>    r{2,5}     anywhere from two to five r's
<BR>    r{2,}      two or more r's
<BR>    r{4}       exactly 4 r's
<BR>    {name}     the expansion of the "name" definition
<BR>               (see above)
<BR>    "[xyz]\"foo"
<BR>               the literal string: [xyz]"foo
<BR>    \X         if X is an 'a', 'b', 'f', 'n', 'r', 't', or 'v',
<BR>                 then the ANSI-C interpretation of \x.
<BR>                 Otherwise, a literal 'X' (used to escape
<BR>                 operators such as '*')
<BR>    \0         a NUL character (ASCII code 0)
<BR>    \123       the character with octal value 123
<BR>    \x2a       the character with hexadecimal value 2a
<BR>    (r)        match an r; parentheses are used to override
<BR>                 precedence (see below)
<BR>
<P><BR>
<P><BR>    rs         the regular expression r followed by the
<BR>                 regular expression s; called "concatenation"
<BR>
<P><BR>
<P><BR>    r|s        either an r or an s
<BR>
<P><BR>
<P><BR>    r/s        an r but only if it is followed by an s.  The
<BR>                 text matched by s is included when determining
<BR>                 whether this rule is the "longest match",
<BR>                 but is then returned to the input before
<BR>                 the action is executed.  So the action only
<BR>                 sees the text matched by r.  This type
<BR>                 of pattern is called trailing context".
<BR>                 (There are some combinations of r/s that flex
<BR>                 cannot match correctly; see notes in the
<BR>                 Deficiencies / Bugs section below regarding
<BR>                 "dangerous trailing context".)
<BR>    ^r         an r, but only at the beginning of a line (i.e.,
<BR>                 which just starting to scan, or right after a
<BR>                 newline has been scanned).
<BR>    r$         an r, but only at the end of a line (i.e., just
<BR>                 before a newline).  Equivalent to "r/\n".
<BR>
<P><BR>               Note that flex's notion of "newline" is exactly
<BR>               whatever the C compiler used to compile flex
<BR>               interprets '\n' as; in particular, on some DOS
<BR>               systems you must either filter out \r's in the
<BR>               input yourself, or explicitly use r/\r\n for "r$".
<BR>
<P><BR>
<P><BR>    &lt;s&gt;r       an r, but only in start condition s (see
<BR>                 below for discussion of start conditions)
<BR>    &lt;s1,s2,s3&gt;r
<BR>               same, but in any of start conditions s1,
<BR>                 s2, or s3
<BR>    &lt;*&gt;r       an r in any start condition, even an exclusive one.
<BR>
<P><BR>
<P><BR>    &lt;&lt;EOF&gt;&gt;    an end-of-file
<BR>    &lt;s1,s2&gt;&lt;&lt;EOF&gt;&gt;
<BR>               an end-of-file when in start condition s1 or s2
<BR>
<P><BR></P></PRE>Note that inside of a character class, all regular expression 
  operators lose their special meaning except escape ('\') and the character 
  class operators, '-', ']', and, at the beginning of the class, '^'. 
  <P>The regular expressions listed above are grouped according to precedence, 
  from highest precedence at the top to lowest at the bottom. Those grouped 
  together have equal precedence. For example, <PRE>
<P><BR>    foo|bar*
<BR>
<P><BR></P></PRE>is the same as <PRE>
<P><BR>    (foo)|(ba(r*))
<BR>
<P><BR></P></PRE>since the '*' operator has higher precedence than 
  concatenation, and concatenation higher than alternation ('|'). This pattern 
  therefore matches <I>either</I> the string "foo" <I>or</I> the string "ba" 
  followed by zero-or-more r's. To match "foo" or zero-or-more "bar"'s, use: <PRE>
<P><BR>    foo|(bar)*
<BR>
<P><BR></P></PRE>and to match zero-or-more "foo"'s-or-"bar"'s: <PRE>
<P><BR>    (foo|bar)*
<BR>
<P><BR></P></PRE>
  <P>In addition to characters and ranges of characters, character classes can 
  also contain character class <I>expressions.</I> These are expressions 
  enclosed inside <B>[:</B> and <B>:]</B> delimiters (which themselves must 
  appear between the '[' and ']' of the character class; other elements may 
  occur inside the character class, too). The valid expressions are: <PRE>
<P><BR>    [:alnum:] [:alpha:] [:blank:]
<BR>    [:cntrl:] [:digit:] [:graph:]
<BR>    [:lower:] [:print:] [:punct:]
<BR>    [:space:] [:upper:] [:xdigit:]
<BR>
<P><BR></P></PRE>These expressions all designate a set of characters 
  equivalent to the corresponding standard C <B>isXXX</B> function. For example, 
  <B>[:alnum:]</B> designates those characters for which <B>isalnum()</B> 
  returns true - i.e., any alphabetic or numeric. Some systems don't provide 
  <B>isblank(),</B> so flex defines <B>[:blank:]</B> as a blank or a tab. 
  <P>For example, the following character classes are all equivalent: <PRE>
<P><BR>    [[:alnum:]]
<BR>    [[:alpha:][:digit:]
<BR>    [[:alpha:]0-9]
<BR>    [a-zA-Z0-9]
<BR>
<P><BR></P></PRE>If your scanner is case-insensitive (the <B>-i</B> flag), 
  then <B>[:upper:]</B> and <B>[:lower:]</B> are equivalent to <B>[:alpha:].</B> 

  <P>Some notes on patterns: 
  <P>
  <DL compact>
    <DT>-
    <DD>A negated character class such as the example "[^A-Z]" above <I>will</I> 
    <I>match</I> <I>a</I> <I>newline</I> unless "\n" (or an equivalent escape 
    sequence) is one of the characters explicitly present in the negated 
    character class (e.g., "[^A-Z\n]"). This is unlike how many other regular 
    expression tools treat negated character classes, but unfortunately the 
    inconsistency is historically entrenched. Matching newlines means that a 
    pattern like [^"]* can match the entire input unless there's another quote 
    in the input. 
    <DT>-
    <DD>A rule can have at most one instance of trailing context (the '/' 
    operator or the '$' operator). The start condition, '^', and 
    "&lt;&lt;EOF&gt;&gt;" patterns can only occur at the beginning of a pattern, 
    and, as well as with '/' and '$', cannot be grouped inside parentheses. A 
    '^' which does not occur at the beginning of a rule or a '$' which does not 
    occur at the end of a rule loses its special properties and is treated as a 
    normal character. 
    <DT>
    <DD>The following are illegal: <PRE>
<P><BR>    foo/bar$
<BR>    &lt;sc1&gt;foo&lt;sc2&gt;bar
<BR>
<P><BR></P></PRE>Note that the first of these, can be written "foo/bar\n". 
    <DT>
    <DD>The following will result in '$' or '^' being treated as a normal 
    character: <PRE>
<P><BR>    foo|(bar$)
<BR>    foo|^bar
<BR>
<P><BR></P></PRE>If what's wanted is a "foo" or a bar-followed-by-a-newline, 
    the following could be used (the special '|' action is explained below): <PRE>
<P><BR>    foo      |
<BR>    bar$     /* action goes here */
<BR>
<P><BR></P></PRE>A similar trick will work for matching a foo or a 
    bar-at-the-beginning-of-a-line. </DD></DL></UL>
<H2>HOW THE INPUT IS MATCHED </H2>
<UL>When the generated scanner is run, it analyzes its input looking for 
  strings which match any of its patterns. If it finds more than one match, it 
  takes the one matching the most text (for trailing context rules, this 
  includes the length of the trailing part, even though it will then be returned 
  to the input). If it finds two or more matches of the same length, the rule 
  listed first in the <I>flex</I> input file is chosen. 
  <P>Once the match is determined, the text corresponding to the match (called 
  the <I>token)</I> is made available in the global character pointer 
  <B>yytext,</B> and its length in the global integer <B>yyleng.</B> The 
  <I>action</I> corresponding to the matched pattern is then executed (a more 
  detailed description of actions follows), and then the remaining input is 
  scanned for another match. 
  <P>If no match is found, then the <I>default</I> <I>rule</I> is executed: the 
  next character in the input is considered matched and copied to the standard 
  output. Thus, the simplest legal <I>flex</I> input is: <PRE>
<P><BR>    %%
<BR>
<P><BR></P></PRE>which generates a scanner that simply copies its input (one 
  character at a time) to its output. 
  <P>Note that <B>yytext</B> can be defined in two different ways: either as a 
  character <I>pointer</I> or as a character <I>array.</I> You can control which 
  definition <I>flex</I> uses by including one of the special directives 
  <B>%pointer</B> or <B>%array</B> in the first (definitions) section of your 
  flex input. The default is <B>%pointer,</B> unless you use the <B>-l</B> lex 
  compatibility option, in which case <B>yytext</B> will be an array. The 
  advantage of using <B>%pointer</B> is substantially faster scanning and no 
  buffer overflow when matching very large tokens (unless you run out of dynamic 
  memory). The disadvantage is that you are restricted in how your actions can 
  modify <B>yytext</B> (see the next section), and calls to the <B>unput()</B> 
  function destroys the present contents of <B>yytext,</B> which can be a 
  considerable porting headache when moving between different <I>lex</I> 
  versions. 
  <P>The advantage of <B>%array</B> is that you can then modify <B>yytext</B> to 
  your heart's content, and calls to <B>unput()</B> do not destroy <B>yytext</B> 
  (see below). Furthermore, existing <I>lex</I> programs sometimes access 
  <B>yytext</B> externally using declarations of the form: <PRE>    extern char yytext[];
<BR></PRE>This definition is erroneous when used with <B>%pointer,</B> but 
  correct for <B>%array.</B> 
  <P><B>%array</B> defines <B>yytext</B> to be an array of <B>YYLMAX</B> 
  characters, which defaults to a fairly large value. You can change the size by 
  simply #define'ing <B>YYLMAX</B> to a different value in the first section of 
  your <I>flex</I> input. As mentioned above, with <B>%pointer</B> yytext grows 
  dynamically to accommodate large tokens. While this means your <B>%pointer</B> 
  scanner can accommodate very large tokens (such as matching entire blocks of 
  comments), bear in mind that each time the scanner must resize <B>yytext</B> 
  it also must rescan the entire token from the beginning, so matching such 
  tokens can prove slow. <B>yytext</B> presently does <I>not</I> dynamically 
  grow if a call to <B>unput()</B> results in too much text being pushed back; 
  instead, a run-time error results. 
  <P>Also note that you cannot use <B>%array</B> with C++ scanner classes (the 
  <B>c++</B> option; see below). </P></UL>
<H2>ACTIONS </H2>
<UL>Each pattern in a rule has a corresponding action, which can be any 
  arbitrary C statement. The pattern ends at the first non-escaped whitespace 
  character; the remainder of the line is its action. If the action is empty, 
  then when the pattern is matched the input token is simply discarded. For 
  example, here is the specification for a program which deletes all occurrences 
  of "zap me" from its input: <PRE>
<P><BR>    %%
<BR>    "zap me"
<BR>
<P><BR></P></PRE>(It will copy all other characters in the input to the output 
  since they will be matched by the default rule.) 
  <P>Here is a program which compresses multiple blanks and tabs down to a 
  single blank, and throws away whitespace found at the end of a line: <PRE>
<P><BR>    %%
<BR>    [ \t]+        putchar( ' ' );
<BR>    [ \t]+$       /* ignore this token */
<BR>
<P><BR></P></PRE>
  <P>If the action contains a '{', then the action spans till the balancing '}' 
  is found, and the action may cross multiple lines. <I>flex</I> knows about C 
  strings and comments and won't be fooled by braces found within them, but also 
  allows actions to begin with <B>%{</B> and will consider the action to be all 
  the text up to the next <B>%}</B> (regardless of ordinary braces inside the 
  action). 
  <P>An action consisting solely of a vertical bar ('|') means "same as the 
  action for the next rule." See below for an illustration. 
  <P>Actions can include arbitrary C code, including <B>return</B> statements to 
  return a value to whatever routine called <B>yylex().</B> Each time 
  <B>yylex()</B> is called it continues processing tokens from where it last 
  left off until it either reaches the end of the file or executes a return. 
  <P>Actions are free to modify <B>yytext</B> except for lengthening it (adding 
  characters to its end--these will overwrite later characters in the input 
  stream). This however does not apply when using <B>%array</B> (see above); in 
  that case, <B>yytext</B> may be freely modified in any way. 
  <P>Actions are free to modify <B>yyleng</B> except they should not do so if 
  the action also includes use of <B>yymore()</B> (see below). 
  <P>There are a number of special directives which can be included within an 
  action: 
  <P>
  <DL compact>
    <DT>-
    <DD><B>ECHO</B> copies yytext to the scanner's output. 
    <DT>-
    <DD><B>BEGIN</B> followed by the name of a start condition places the 
    scanner in the corresponding start condition (see below). 
    <DT>-
    <DD><B>REJECT</B> directs the scanner to proceed on to the "second best" 
    rule which matched the input (or a prefix of the input). The rule is chosen 
    as described above in "How the Input is Matched", and <B>yytext</B> and 
    <B>yyleng</B> set up appropriately. It may either be one which matched as 
    much text as the originally chosen rule but came later in the <I>flex</I> 
    input file, or one which matched less text. For example, the following will 
    both count the words in the input and call the routine special() whenever 
    "frob" is seen: <PRE>
<P><BR>            int word_count = 0;
<BR>    %%
<BR>
<P><BR>    frob        special(); REJECT;
<BR>    [^ \t\n]+   ++word_count;
<BR>
<P><BR></P></PRE>Without the <B>REJECT,</B> any "frob"'s in the input would 
    not be counted as words, since the scanner normally executes only one action 
    per token. Multiple <B>REJECT's</B> are allowed, each one finding the next 
    best choice to the currently active rule. For example, when the following 
    scanner scans the token "abcd", it will write "abcdabcaba" to the output: <PRE>
<P><BR>    %%
<BR>    a        |
<BR>    ab       |
<BR>    abc      |
<BR>    abcd     ECHO; REJECT;
<BR>    .|\n     /* eat up any unmatched character */
<BR>
<P><BR></P></PRE>(The first three rules share the fourth's action since they 
    use the special '|' action.) <B>REJECT</B> is a particularly expensive 
    feature in terms of scanner performance; if it is used in <I>any</I> of the 
    scanner's actions it will slow down <I>all</I> of the scanner's matching. 
    Furthermore, <B>REJECT</B> cannot be used with the <I>-Cf</I> or <I>-CF</I> 
    options (see below). 
    <DT>
    <DD>Note also that unlike the other special actions, <B>REJECT</B> is a 
    <I>branch;</I> code immediately following it in the action will <I>not</I> 
    be executed. 
    <DT>-
    <DD><B>yymore()</B> tells the scanner that the next time it matches a rule, 
    the corresponding token should be <I>appended</I> onto the current value of 
    <B>yytext</B> rather than replacing it. For example, given the input 
    "mega-kludge" the following will write "mega-mega-kludge" to the output: <PRE>
<P><BR>    %%
<BR>    mega-    ECHO; yymore();
<BR>    kludge   ECHO;
<BR>
<P><BR></P></PRE>First "mega-" is matched and echoed to the output. Then 
    "kludge" is matched, but the previous "mega-" is still hanging around at the 
    beginning of <B>yytext</B> so the <B>ECHO</B> for the "kludge" rule will 
    actually write "mega-kludge". </DD></DL>
  <P>Two notes regarding use of <B>yymore().</B> First, <B>yymore()</B> depends 
  on the value of <I>yyleng</I> correctly reflecting the size of the current 
  token, so you must not modify <I>yyleng</I> if you are using <B>yymore().</B> 
  Second, the presence of <B>yymore()</B> in the scanner's action entails a 
  minor performance penalty in the scanner's matching speed. 
  <P>
  <DL compact>
    <DT>-
    <DD><B>yyless(n)</B> returns all but the first <I>n</I> characters of the 
    current token back to the input stream, where they will be rescanned when 
    the scanner looks for the next match. <B>yytext</B> and <B>yyleng</B> are 
    adjusted appropriately (e.g., <B>yyleng</B> will now be equal to <I>n</I> ). 
    For example, on the input "foobar" the following will write out "foobarbar": 
<PRE>
<P><BR>    %%
<BR>    foobar    ECHO; yyless(3);
<BR>    [a-z]+    ECHO;
<BR>
<P><BR></P></PRE>An argument of 0 to <B>yyless</B> will cause the entire 
    current input string to be scanned again. Unless you've changed how the 
    scanner will subsequently process its input (using <B>BEGIN,</B> for 
    example), this will result in an endless loop. </DD></DL>
  <P>Note that <B>yyless</B> is a macro and can only be used in the flex input 
  file, not from other source files. 
  <P>
  <DL compact>
    <DT>-
    <DD><B>unput(c)</B> puts the character <I>c</I> back onto the input stream. 
    It will be the next character scanned. The following action will take the 
    current token and cause it to be rescanned enclosed in parentheses. <PRE>
<P><BR>    {
<BR>    int i;
<BR>    /* Copy yytext because unput() trashes yytext */
<BR>    char *yycopy = strdup( yytext );
<BR>    unput( ')' );
<BR>    for ( i = yyleng - 1; i &gt;= 0; --i )
<BR>        unput( yycopy[i] );
<BR>    unput( '(' );
<BR>    free( yycopy );
<BR>    }
<BR>
<P><BR></P></PRE>Note that since each <B>unput()</B> puts the given 
    character back at the <I>beginning</I> of the input stream, pushing back 
    strings must be done back-to-front. </DD></DL>
  <P>An important potential problem when using <B>unput()</B> is that if you are 
  using <B>%pointer</B> (the default), a call to <B>unput()</B> <I>destroys</I> 
  the contents of <I>yytext,</I> starting with its rightmost character and 
  devouring one character to the left with each call. If you need the value of 
  yytext preserved after a call to <B>unput()</B> (as in the above example), you 
  must either first copy it elsewhere, or build your scanner using <B>%array</B> 
  instead (see How The Input Is Matched). 
  <P>Finally, note that you cannot put back <B>EOF</B> to attempt to mark the 
  input stream with an end-of-file. 
  <P>
  <DL compact>
    <DT>-
    <DD><B>input()</B> reads the next character from the input stream. For 
    example, the following is one way to eat up C comments: <PRE>
<P><BR>    %%
<BR>    "/*"        {
<BR>                register int c;
<BR>
<P><BR>                for ( ; ; )
<BR>                    {
<BR>                    while ( (c = input()) != '*' &amp;&amp;
<BR>                            c != EOF )
<BR>                        ;    /* eat up text of comment */
<BR>
<P><BR>                    if ( c == '*' )
<BR>                        {
<BR>                        while ( (c = input()) == '*' )
<BR>                            ;
<BR>                        if ( c == '/' )
<BR>                            break;    /* found the end */
<BR>                        }
<BR>
<P><BR>                    if ( c == EOF )
<BR>                        {
<BR>                        error( "EOF in comment" );
<BR>                        break;
<BR>                        }
<BR>                    }
<BR>                }
<BR>
<P><BR></P></PRE>(Note that if the scanner is compiled using <B>C++,</B> 
    then <B>input()</B> is instead referred to as <B>yyinput(),</B> in order to 
    avoid a name clash with the <B>C++</B> stream by the name of <I>input.)</I> 
    <DT>-
    <DD><B>YY_FLUSH_BUFFER</B> flushes the scanner's internal buffer so that the 
    next time the scanner attempts to match a token, it will first refill the 
    buffer using <B>YY_INPUT</B> (see The Generated Scanner, below). This action 
    is a special case of the more general <B>yy_flush_buffer()</B> function, 
    described below in the section Multiple Input Buffers. 
    <DT>-
    <DD><B>yyterminate()</B> can be used in lieu of a return statement in an 
    action. It terminates the scanner and returns a 0 to the scanner's caller, 
    indicating "all done". By default, <B>yyterminate()</B> is also called when 
    an end-of-file is encountered. It is a macro and may be redefined. 
</DD></DL></UL>
<H2>THE GENERATED SCANNER </H2>
<UL>The output of <I>flex</I> is the file <B>lex.yy.c,</B> which contains the 
  scanning routine <B>yylex(),</B> a number of tables used by it for matching 
  tokens, and a number of auxiliary routines and macros. By default, 
  <B>yylex()</B> is declared as follows: <PRE>
<P><BR>    int yylex()
<BR>        {
<BR>        ... various definitions and the actions in here ...
<BR>        }
<BR>
<P><BR></P></PRE>(If your environment supports function prototypes, then it 
  will be "int yylex( void )".) This definition may be changed by defining the 
  "YY_DECL" macro. For example, you could use: <PRE>
<P><BR>    #define YY_DECL float lexscan( a, b ) float a, b;
<BR>
<P><BR></P></PRE>to give the scanning routine the name <I>lexscan,</I> 
  returning a float, and taking two floats as arguments. Note that if you give 
  arguments to the scanning routine using a K&amp;R-style/non-prototyped 
  function declaration, you must terminate the definition with a semi-colon (;). 

  <P>Whenever <B>yylex()</B> is called, it scans tokens from the global input 
  file <I>yyin</I> (which defaults to stdin). It continues until it either 
  reaches an end-of-file (at which point it returns the value 0) or one of its 
  actions executes a <I>return</I> statement. 
  <P>If the scanner reaches an end-of-file, subsequent calls are undefined 
  unless either <I>yyin</I> is pointed at a new input file (in which case 
  scanning continues from that file), or <B>yyrestart()</B> is called. 
  <B>yyrestart()</B> takes one argument, a <B>FILE</B> <B>*</B> pointer (which 
  can be nil, if you've set up <B>YY_INPUT</B> to scan from a source other than 
  <I>yyin),</I> and initializes <I>yyin</I> for scanning from that file. 
  Essentially there is no difference between just assigning <I>yyin</I> to a new 
  input file or using <B>yyrestart()</B> to do so; the latter is available for 
  compatibility with previous versions of <I>flex,</I> and because it can be 
  used to switch input files in the middle of scanning. It can also be used to 
  throw away the current input buffer, by calling it with an argument of 
  <I>yyin;</I> but better is to use <B>YY_FLUSH_BUFFER</B> (see above). Note 
  that <B>yyrestart()</B> does <I>not</I> reset the start condition to 
  <B>INITIAL</B> (see Start Conditions, below). 
  <P>If <B>yylex()</B> stops scanning due to executing a <I>return</I> statement 
  in one of the actions, the scanner may then be called again and it will resume 
  scanning where it left off. 
  <P>By default (and for purposes of efficiency), the scanner uses block-reads 
  rather than simple <I>getc()</I> calls to read characters from <I>yyin.</I> 
  The nature of how it gets its input can be controlled by defining the 
  <B>YY_INPUT</B> macro. YY_INPUT's calling sequence is 
  "YY_INPUT(buf,result,max_size)". Its action is to place up to <I>max_size</I> 
  characters in the character array <I>buf</I> and return in the integer 
  variable <I>result</I> either the number of characters read or the constant 
  YY_NULL (0 on Unix systems) to indicate EOF. The default YY_INPUT reads from 
  the global file-pointer "yyin". 
  <P>A sample definition of YY_INPUT (in the definitions section of the input 
  file): <PRE>
<P><BR>    %{
<BR>    #define YY_INPUT(buf,result,max_size) \
<BR>        { \
<BR>        int c = getchar(); \
<BR>        result = (c == EOF) ? YY_NULL : (buf[0] = c, 1); \
<BR>        }
<BR>    %}
<BR>
<P><BR></P></PRE>This definition will change the input processing to occur one 
  character at a time. 
  <P>When the scanner receives an end-of-file indication from YY_INPUT, it then 
  checks the <B>yywrap()</B> function. If <B>yywrap()</B> returns false (zero), 
  then it is assumed that the function has gone ahead and set up <I>yyin</I> to 
  point to another input file, and scanning continues. If it returns true 
  (non-zero), then the scanner terminates, returning 0 to its caller. Note that 
  in either case, the start condition remains unchanged; it does <I>not</I> 
  revert to <B>INITIAL.</B> 
  <P>If you do not supply your own version of <B>yywrap(),</B> then you must 
  either use <B>%option</B> <B>noyywrap</B> (in which case the scanner behaves 
  as though <B>yywrap()</B> returned 1), or you must link with <B>-lfl</B> to 
  obtain the default version of the routine, which always returns 1. 
  <P>Three routines are available for scanning from in-memory buffers rather 
  than files: <B>yy_scan_string(),</B> <B>yy_scan_bytes(),</B> and 
  <B>yy_scan_buffer().</B> See the discussion of them below in the section 
  Multiple Input Buffers. 
  <P>The scanner writes its <B>ECHO</B> output to the <I>yyout</I> global 
  (default, stdout), which may be redefined by the user simply by assigning it 
  to some other <B>FILE</B> pointer. </P></UL>
<H2>START CONDITIONS </H2>
<UL><I>flex</I> provides a mechanism for conditionally activating rules. Any 
  rule whose pattern is prefixed with "&lt;sc&gt;" will only be active when the 
  scanner is in the start condition named "sc". For example, <PRE>
<P><BR>    &lt;STRING&gt;[^"]*        { /* eat up the string body ... */
<BR>                ...
<BR>                }
<BR>
<P><BR></P></PRE>will be active only when the scanner is in the "STRING" start 
  condition, and <PRE>
<P><BR>    &lt;INITIAL,STRING,QUOTE&gt;\.        { /* handle an escape ... */
<BR>                ...
<BR>                }
<BR>
<P><BR></P></PRE>will be active only when the current start condition is 
  either "INITIAL", "STRING", or "QUOTE". 
  <P>Start conditions are declared in the definitions (first) section of the 
  input using unindented lines beginning with either <B>%s</B> or <B>%x</B> 
  followed by a list of names. The former declares <I>inclusive</I> start 
  conditions, the latter <I>exclusive</I> start conditions. A start condition is 
  activated using the <B>BEGIN</B> action. Until the next <B>BEGIN</B> action is 
  executed, rules with the given start condition will be active and rules with 
  other start conditions will be inactive. If the start condition is 
  <I>inclusive,</I> then rules with no start conditions at all will also be 
  active. If it is <I>exclusive,</I> then <I>only</I> rules qualified with the 
  start condition will be active. A set of rules contingent on the same 
  exclusive start condition describe a scanner which is independent of any of 
  the other rules in the <I>flex</I> input. Because of this, exclusive start 
  conditions make it easy to specify "mini-scanners" which scan portions of the 
  input that are syntactically different from the rest (e.g., comments). 
  <P>If the distinction between inclusive and exclusive start conditions is 
  still a little vague, here's a simple example illustrating the connection 
  between the two. The set of rules: <PRE>
<P><BR>    %s example
<BR>    %%
<BR>
<P><BR>    &lt;example&gt;foo   do_something();
<BR>
<P><BR>    bar            something_else();
<BR>
<P><BR></P></PRE>is equivalent to <PRE>
<P><BR>    %x example
<BR>    %%
<BR>
<P><BR>    &lt;example&gt;foo   do_something();
<BR>
<P><BR>    &lt;INITIAL,example&gt;bar    something_else();
<BR>
<P><BR></P></PRE>Without the <B>&lt;INITIAL,example&gt;</B> qualifier, the 
  <I>bar</I> pattern in the second example wouldn't be active (i.e., couldn't 
  match) when in start condition <B>example.</B> If we just used 
  <B>&lt;example&gt;</B> to qualify <I>bar,</I> though, then it would only be 
  active in <B>example</B> and not in <B>INITIAL,</B> while in the first example 
  it's active in both, because in the first example the <B>example</B> startion 
  condition is an <I>inclusive</I> <B>(%s)</B> start condition. 
  <P>Also note that the special start-condition specifier <B>&lt;*&gt;</B> 
  matches every start condition. Thus, the above example could also have been 
  written; <PRE>
<P><BR>    %x example
<BR>    %%
<BR>
<P><BR>    &lt;example&gt;foo   do_something();
<BR>
<P><BR>    &lt;*&gt;bar    something_else();
<BR>
<P><BR></P></PRE>
  <P>The default rule (to <B>ECHO</B> any unmatched character) remains active in 
  start conditions. It is equivalent to: <PRE>
<P><BR>    &lt;*&gt;.|\n     ECHO;
<BR>
<P><BR></P></PRE>
  <P><B>BEGIN(0)</B> returns to the original state where only the rules with no 
  start conditions are active. This state can also be referred to as the 
  start-condition "INITIAL", so <B>BEGIN(INITIAL)</B> is equivalent to 
  <B>BEGIN(0).</B> (The parentheses around the start condition name are not 
  required but are considered good style.) 
  <P><B>BEGIN</B> actions can also be given as indented code at the beginning of 
  the rules section. For example, the following will cause the scanner to enter 
  the "SPECIAL" start condition whenever <B>yylex()</B> is called and the global 
  variable <I>enter_special</I> is true: <PRE>
<P><BR>            int enter_special;
<BR>
<P><BR>    %x SPECIAL
<BR>    %%
<BR>            if ( enter_special )
<BR>                BEGIN(SPECIAL);
<BR>
<P><BR>    &lt;SPECIAL&gt;blahblahblah
<BR>    ...more rules follow...
<BR>
<P><BR></P></PRE>
  <P>To illustrate the uses of start conditions, here is a scanner which 
  provides two different interpretations of a string like "123.456". By default 
  it will treat it as as three tokens, the integer "123", a dot ('.'), and the 
  integer "456". But if the string is preceded earlier in the line by the string 
  "expect-floats" it will treat it as a single token, the floating-point number 
  123.456: <PRE>
<P><BR>    %{
<BR>    #include &lt;math.h&gt;
<BR>    %}
<BR>    %s expect
<BR>
<P><BR>    %%
<BR>    expect-floats        BEGIN(expect);
<BR>
<P><BR>    &lt;expect&gt;[0-9]+"."[0-9]+      {
<BR>                printf( "found a float, = %f\n",
<BR>                        atof( yytext ) );
<BR>                }
<BR>    &lt;expect&gt;\n           {
<BR>                /* that's the end of the line, so
<BR>                 * we need another "expect-number"
<BR>                 * before we'll recognize any more
<BR>                 * numbers
<BR>                 */
<BR>                BEGIN(INITIAL);
<BR>                }
<BR>
<P><BR>    [0-9]+      {
<BR>                printf( "found an integer, = %d\n",
<BR>                        atoi( yytext ) );
<BR>                }
<BR>
<P><BR>    "."         printf( "found a dot\n" );
<BR>
<P><BR></P></PRE>Here is a scanner which recognizes (and discards) C comments 
  while maintaining a count of the current input line. <PRE>
<P><BR>    %x comment
<BR>    %%
<BR>            int line_num = 1;
<BR>
<P><BR>    "/*"         BEGIN(comment);
<BR>
<P><BR>    &lt;comment&gt;[^*\n]*        /* eat anything that's not a '*' */
<BR>    &lt;comment&gt;"*"+[^*/\n]*   /* eat up '*'s not followed by '/'s */
<BR>    &lt;comment&gt;\n             ++line_num;
<BR>    &lt;comment&gt;"*"+"/"        BEGIN(INITIAL);
<BR>
<P><BR></P></PRE>This scanner goes to a bit of trouble to match as much text 
  as possible with each rule. In general, when attempting to write a high-speed 
  scanner try to match as much possible in each rule, as it's a big win. 
  <P>Note that start-conditions names are really integer values and can be 
  stored as such. Thus, the above could be extended in the following fashion: <PRE>
<P><BR>    %x comment foo
<BR>    %%
<BR>            int line_num = 1;
<BR>            int comment_caller;
<BR>
<P><BR>    "/*"         {
<BR>                 comment_caller = INITIAL;
<BR>                 BEGIN(comment);
<BR>                 }
<BR>
<P><BR>    ...
<BR>
<P><BR>    &lt;foo&gt;"/*"    {
<BR>                 comment_caller = foo;
<BR>                 BEGIN(comment);
<BR>                 }
<BR>
<P><BR>    &lt;comment&gt;[^*\n]*        /* eat anything that's not a '*' */
<BR>    &lt;comment&gt;"*"+[^*/\n]*   /* eat up '*'s not followed by '/'s */
<BR>    &lt;comment&gt;\n             ++line_num;
<BR>    &lt;comment&gt;"*"+"/"        BEGIN(comment_caller);
<BR>
<P><BR></P></PRE>Furthermore, you can access the current start condition using 
  the integer-valued <B>YY_START</B> macro. For example, the above assignments 
  to <I>comment_caller</I> could instead be written <PRE>
<P><BR>    comment_caller = YY_START;
<BR>
<P><BR></P></PRE>Flex provides <B>YYSTATE</B> as an alias for <B>YY_START</B> 
  (since that is what's used by AT&amp;T <I>lex).</I> 
  <P>Note that start conditions do not have their own name-space; %s's and %x's 
  declare names in the same fashion as #define's. 
  <P>Finally, here's an example of how to match C-style quoted strings using 
  exclusive start conditions, including expanded escape sequences (but not 
  including checking for a string that's too long): <PRE>
<P><BR>    %x str
<BR>
<P><BR>    %%
<BR>            char string_buf[MAX_STR_CONST];
<BR>            char *string_buf_ptr;
<BR>
<P><BR>
<P><BR>    \"      string_buf_ptr = string_buf; BEGIN(str);
<BR>
<P><BR>    &lt;str&gt;\"        { /* saw closing quote - all done */
<BR>            BEGIN(INITIAL);
<BR>            *string_buf_ptr = '\0';
<BR>            /* return string constant token type and
<BR>             * value to parser
<BR>             */
<BR>            }
<BR>
<P><BR>    &lt;str&gt;\n        {
<BR>            /* error - unterminated string constant */
<BR>            /* generate error message */
<BR>            }
<BR>
<P><BR>    &lt;str&gt;\\[0-7]{1,3} {
<BR>            /* octal escape sequence */
<BR>            int result;
<BR>
<P><BR>            (void) sscanf( yytext + 1, "%o", &amp;result );
<BR>
<P><BR>            if ( result &gt; 0xff )
<BR>                    /* error, constant is out-of-bounds */
<BR>
<P><BR>            *string_buf_ptr++ = result;
<BR>            }
<BR>
<P><BR>    &lt;str&gt;\\[0-9]+ {
<BR>            /* generate error - bad escape sequence; something
<BR>             * like '\48' or '\0777777'
<BR>             */
<BR>            }
<BR>
<P><BR>    &lt;str&gt;\\n  *string_buf_ptr++ = '\n';
<BR>    &lt;str&gt;\\t  *string_buf_ptr++ = '\t';
<BR>    &lt;str&gt;\\r  *string_buf_ptr++ = '\r';
<BR>    &lt;str&gt;\\b  *string_buf_ptr++ = '\b';
<BR>    &lt;str&gt;\\f  *string_buf_ptr++ = '\f';
<BR>
<P><BR>    &lt;str&gt;\\(.|\n)  *string_buf_ptr++ = yytext[1];
<BR>
<P><BR>    &lt;str&gt;[^\\\n\"]+        {
<BR>            char *yptr = yytext;
<BR>
<P><BR>            while ( *yptr )
<BR>                    *string_buf_ptr++ = *yptr++;
<BR>            }
<BR>
<P><BR></P></PRE>
  <P>Often, such as in some of the examples above, you wind up writing a whole 
  bunch of rules all preceded by the same start condition(s). Flex makes this a 
  little easier and cleaner by introducing a notion of start condition 
  <I>scope.</I> A start condition scope is begun with: <PRE>
<P><BR>    &lt;SCs&gt;{
<BR>
<P><BR></P></PRE>where <I>SCs</I> is a list of one or more start conditions. 
  Inside the start condition scope, every rule automatically has the prefix 
  <I>&lt;SCs&gt;</I> applied to it, until a <I>'}'</I> which matches the initial 
  <I>'{'.</I> So, for example, <PRE>
<P><BR>    &lt;ESC&gt;{
<BR>        "\\n"   return '\n';
<BR>        "\\r"   return '\r';
<BR>        "\\f"   return '\f';
<BR>        "\\0"   return '\0';
<BR>    }
<BR>
<P><BR></P></PRE>is equivalent to: <PRE>
<P><BR>    &lt;ESC&gt;"\\n"  return '\n';
<BR>    &lt;ESC&gt;"\\r"  return '\r';
<BR>    &lt;ESC&gt;"\\f"  return '\f';
<BR>    &lt;ESC&gt;"\\0"  return '\0';
<BR>
<P><BR></P></PRE>Start condition scopes may be nested. 
  <P>Three routines are available for manipulating stacks of start conditions: 
  <P>
  <DL compact>
    <DT><B>void</B> <B>yy_push_state(int</B> <B>new_state)</B> 
    <DD>pushes the current start condition onto the top of the start condition 
    stack and switches to <I>new_state</I> as though you had used <B>BEGIN</B> 
    <B>new_state</B> (recall that start condition names are also integers). 
    <DT><B>void</B> <B>yy_pop_state()</B> 
    <DD>pops the top of the stack and switches to it via <B>BEGIN.</B> 
    <DT><B>int</B> <B>yy_top_state()</B> 
    <DD>returns the top of the stack without altering the stack's contents. 
  </DD></DL>
  <P>The start condition stack grows dynamically and so has no built-in size 
  limitation. If memory is exhausted, program execution aborts. 
  <P>To use start condition stacks, your scanner must include a <B>%option</B> 
  <B>stack</B> directive (see Options below). </P></UL>
<H2>MULTIPLE INPUT BUFFERS </H2>
<UL>Some scanners (such as those which support "include" files) require 
  reading from several input streams. As <I>flex</I> scanners do a large amount 
  of buffering, one cannot control where the next input will be read from by 
  simply writing a <B>YY_INPUT</B> which is sensitive to the scanning context. 
  <B>YY_INPUT</B> is only called when the scanner reaches the end of its buffer, 
  which may be a long time after scanning a statement such as an "include" which 
  requires switching the input source. 
  <P>To negotiate these sorts of problems, <I>flex</I> provides a mechanism for 
  creating and switching between multiple input buffers. An input buffer is 
  created by using: <PRE>
<P><BR>    YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )
<BR>
<P><BR></P></PRE>which takes a <I>FILE</I> pointer and a size and creates a 
  buffer associated with the given file and large enough to hold <I>size</I> 
  characters (when in doubt, use <B>YY_BUF_SIZE</B> for the size). It returns a 
  <B>YY_BUFFER_STATE</B> handle, which may then be passed to other routines (see 
  below). The <B>YY_BUFFER_STATE</B> type is a pointer to an opaque 
  <B>struct</B> <B>yy_buffer_state</B> structure, so you may safely initialize 
  YY_BUFFER_STATE variables to <B>((YY_BUFFER_STATE)</B> <B>0)</B> if you wish, 
  and also refer to the opaque structure in order to correctly declare input 
  buffers in source files other than that of your scanner. Note that the 
  <I>FILE</I> pointer in the call to <B>yy_create_buffer</B> is only used as the 
  value of <I>yyin</I> seen by <B>YY_INPUT;</B> if you redefine <B>YY_INPUT</B> 
  so it no longer uses <I>yyin,</I> then you can safely pass a nil <I>FILE</I> 
  pointer to <B>yy_create_buffer.</B> You select a particular buffer to scan 
  from using: <PRE>
<P><BR>    void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
<BR>
<P><BR></P></PRE>switches the scanner's input buffer so subsequent tokens will 
  come from <I>new_buffer.</I> Note that <B>yy_switch_to_buffer()</B> may be 
  used by yywrap() to set things up for continued scanning, instead of opening a 
  new file and pointing <I>yyin</I> at it. Note also that switching input 
  sources via either <B>yy_switch_to_buffer()</B> or <B>yywrap()</B> does 
  <I>not</I> change the start condition. <PRE>
<P><BR>    void yy_delete_buffer( YY_BUFFER_STATE buffer )
<BR>
<P><BR></P></PRE>is used to reclaim the storage associated with a buffer. You 
  can also clear the current contents of a buffer using: <PRE>
<P><BR>    void yy_flush_buffer( YY_BUFFER_STATE buffer )
<BR>
<P><BR></P></PRE>This function discards the buffer's contents, so the next 
  time the scanner attempts to match a token from the buffer, it will first fill 
  the buffer anew using <B>YY_INPUT.</B> 
  <P><B>yy_new_buffer()</B> is an alias for <B>yy_create_buffer(),</B> provided 
  for compatibility with the C++ use of <I>new</I> and <I>delete</I> for 
  creating and destroying dynamic objects. 
  <P>Finally, the <B>YY_CURRENT_BUFFER</B> macro returns a 
  <B>YY_BUFFER_STATE</B> handle to the current buffer. 
  <P>Here is an example of using these features for writing a scanner which 
  expands include files (the <B>&lt;&lt;EOF&gt;&gt;</B> feature is discussed 
  below): <PRE>
<P><BR>    /* the "incl" state is used for picking up the name
<BR>     * of an include file
<BR>     */
<BR>    %x incl
<BR>
<P><BR>    %{
<BR>    #define MAX_INCLUDE_DEPTH 10
<BR>    YY_BUFFER_STATE include_stack[MAX_INCLUDE_DEPTH];
<BR>    int include_stack_ptr = 0;
<BR>    %}
<BR>
<P><BR>    %%
<BR>    include             BEGIN(incl);
<BR>
<P><BR>    [a-z]+              ECHO;
<BR>    [^a-z\n]*\n?        ECHO;
<BR>
<P><BR>    &lt;incl&gt;[ \t]*      /* eat the whitespace */
<BR>    &lt;incl&gt;[^ \t\n]+   { /* got the include file name */
<BR>            if ( include_stack_ptr &gt;= MAX_INCLUDE_DEPTH )
<BR>                {
<BR>                fprintf( stderr, "Includes nested too deeply" );
<BR>                exit( 1 );
<BR>                }
<BR>
<P><BR>            include_stack[include_stack_ptr++] =
<BR>                YY_CURRENT_BUFFER;
<BR>
<P><BR>            yyin = fopen( yytext, "r" );
<BR>
<P><BR>            if ( ! yyin )
<BR>                error( ... );
<BR>
<P><BR>            yy_switch_to_buffer(
<BR>                yy_create_buffer( yyin, YY_BUF_SIZE ) );
<BR>
<P><BR>            BEGIN(INITIAL);
<BR>            }
<BR>
<P><BR>    &lt;&lt;EOF&gt;&gt; {
<BR>            if ( --include_stack_ptr &lt; 0 )
<BR>                {
<BR>                yyterminate();
<BR>                }
<BR>
<P><BR>            else
<BR>                {
<BR>                yy_delete_buffer( YY_CURRENT_BUFFER );
<BR>                yy_switch_to_buffer(
<BR>                     include_stack[include_stack_ptr] );
<BR>                }
<BR>            }
<BR>
<P><BR></P></PRE>Three routines are available for setting up input buffers for 
  scanning in-memory strings instead of files. All of them create a new input 
  buffer for scanning the string, and return a corresponding 
  <B>YY_BUFFER_STATE</B> handle (which you should delete with 
  <B>yy_delete_buffer()</B> when done with it). They also switch to the new 
  buffer using <B>yy_switch_to_buffer(),</B> so the next call to <B>yylex()</B> 
  will start scanning the string. 
  <P>
  <DL compact>
    <DT><B>yy_scan_string(const</B> <B>char</B> <B>*str)</B> 
    <DD>scans a NUL-terminated string. 
    <DT><B>yy_scan_bytes(const</B> <B>char</B> <B>*bytes,</B> <B>int</B> 
    <B>len)</B> 
    <DD>scans <I>len</I> bytes (including possibly NUL's) starting at location 
    <I>bytes.</I> </DD></DL>
  <P>Note that both of these functions create and scan a <I>copy</I> of the 
  string or bytes. (This may be desirable, since <B>yylex()</B> modifies the 
  contents of the buffer it is scanning.) You can avoid the copy by using: 
  <P>
  <DL compact>
    <DT><B>yy_scan_buffer(char</B> <B>*base,</B> <B>yy_size_t</B> <B>size)</B> 
    <DD>which scans in place the buffer starting at <I>base,</I> consisting of 
    <I>size</I> bytes, the last two bytes of which <I>must</I> be 
    <B>YY_END_OF_BUFFER_CHAR</B> (ASCII NUL). These last two bytes are not 
    scanned; thus, scanning consists of <B>base[0]</B> through 
    <B>base[size-2],</B> inclusive. 
    <DT>
    <DD>If you fail to set up <I>base</I> in this manner (i.e., forget the final 
    two <B>YY_END_OF_BUFFER_CHAR</B> bytes), then <B>yy_scan_buffer()</B> 
    returns a nil pointer instead of creating a new input buffer. 
    <DT>
    <DD>The type <B>yy_size_t</B> is an integral type to which you can cast an 
    integer expression reflecting the size of the buffer. </DD></DL></UL>
<H2>END-OF-FILE RULES </H2>
<UL>The special rule "&lt;&lt;EOF&gt;&gt;" indicates actions which are to be 
  taken when an end-of-file is encountered and yywrap() returns non-zero (i.e., 
  indicates no further files to process). The action must finish by doing one of 
  four things: 
  <P>
  <DL compact>
    <DT>-
    <DD>assigning <I>yyin</I> to a new input file (in previous versions of flex, 
    after doing the assignment you had to call the special action 
    <B>YY_NEW_FILE;</B> this is no longer necessary); 
    <DT>-
    <DD>executing a <I>return</I> statement; 
    <DT>-
    <DD>executing the special <B>yyterminate()</B> action; 
    <DT>-
    <DD>or, switching to a new buffer using <B>yy_switch_to_buffer()</B> as 
    shown in the example above. </DD></DL>
  <P>&lt;&lt;EOF&gt;&gt; rules may not be used with other patterns; they may 
  only be qualified with a list of start conditions. If an unqualified 
  &lt;&lt;EOF&gt;&gt; rule is given, it applies to <I>all</I> start conditions 
  which do not already have &lt;&lt;EOF&gt;&gt; actions. To specify an 
  &lt;&lt;EOF&gt;&gt; rule for only the initial start condition, use <PRE>
<P><BR>    &lt;INITIAL&gt;&lt;&lt;EOF&gt;&gt;
<BR>
<P><BR></P></PRE>
  <P>These rules are useful for catching things like unclosed comments. An 
  example: <PRE>
<P><BR>    %x quote
<BR>    %%
<BR>
<P><BR>    ...other rules for dealing with quotes...
<BR>
<P><BR>    &lt;quote&gt;&lt;&lt;EOF&gt;&gt;   {
<BR>             error( "unterminated quote" );
<BR>             yyterminate();
<BR>             }
<BR>    &lt;&lt;EOF&gt;&gt;  {
<BR>             if ( *++filelist )
<BR>                 yyin = fopen( *filelist, "r" );
<BR>             else
<BR>                yyterminate();
<BR>             }
<BR>
<P><BR></P></PRE></UL>
<H2>MISCELLANEOUS MACROS </H2>
<UL>The macro <B>YY_USER_ACTION</B> can be defined to provide an action which 
  is always executed prior to the matched rule's action. For example, it could 
  be #define'd to call a routine to convert yytext to lower-case. When 
  <B>YY_USER_ACTION</B> is invoked, the variable <I>yy_act</I> gives the number 
  of the matched rule (rules are numbered starting with 1). Suppose you want to 
  profile how often each of your rules is matched. The following would do the 
  trick: <PRE>
<P><BR>    #define YY_USER_ACTION ++ctr[yy_act]
<BR>
<P><BR></P></PRE>where <I>ctr</I> is an array to hold the counts for the 
  different rules. Note that the macro <B>YY_NUM_RULES</B> gives the total 
  number of rules (including the default rule, even if you use <B>-s),</B> so a 
  correct declaration for <I>ctr</I> is: <PRE>
<P><BR>    int ctr[YY_NUM_RULES];
<BR>
<P><BR></P></PRE>
  <P>The macro <B>YY_USER_INIT</B> may be defined to provide an action which is 
  always executed before the first scan (and before the scanner's internal 
  initializations are done). For example, it could be used to call a routine to 
  read in a data table or open a logging file. 
  <P>The macro <B>yy_set_interactive(is_interactive)</B> can be used to control 
  whether the current buffer is considered <I>interactive.</I> An interactive 
  buffer is processed more slowly, but must be used when the scanner's input 
  source is indeed interactive to avoid problems due to waiting to fill buffers 
  (see the discussion of the <B>-I</B> flag below). A non-zero value in the 
  macro invocation marks the buffer as interactive, a zero value as 
  non-interactive. Note that use of this macro overrides <B>%option</B> 
  <B>always-interactive</B> or <B>%option</B> <B>never-interactive</B> (see 
  Options below). <B>yy_set_interactive()</B> must be invoked prior to beginning 
  to scan the buffer that is (or is not) to be considered interactive. 
  <P>The macro <B>yy_set_bol(at_bol)</B> can be used to control whether the 
  current buffer's scanning context for the next token match is done as though 
  at the beginning of a line. A non-zero macro argument makes rules anchored 
  with '^' active, while a zero argument makes '^' rules inactive. 
  <P>The macro <B>YY_AT_BOL()</B> returns true if the next token scanned from 
  the current buffer will have '^' rules active, false otherwise. 
  <P>In the generated scanner, the actions are all gathered in one large switch 
  statement and separated using <B>YY_BREAK,</B> which may be redefined. By 
  default, it is simply a "break", to separate each rule's action from the 
  following rule's. Redefining <B>YY_BREAK</B> allows, for example, C++ users to 
  #define YY_BREAK to do nothing (while being very careful that every rule ends 
  with a "break" or a "return"!) to avoid suffering from unreachable statement 
  warnings where because a rule's action ends with "return", the <B>YY_BREAK</B> 
  is inaccessible. </P></UL>
<H2>VALUES AVAILABLE TO THE USER </H2>
<UL>This section summarizes the various values available to the user in the 
  rule actions. 
  <P>
  <DL compact>
    <DT>-
    <DD><B>char</B> <B>*yytext</B> holds the text of the current token. It may 
    be modified but not lengthened (you cannot append characters to the end). 
    <DT>
    <DD>If the special directive <B>%array</B> appears in the first section of 
    the scanner description, then <B>yytext</B> is instead declared <B>char</B> 
    <B>yytext[YYLMAX],</B> where <B>YYLMAX</B> is a macro definition that you 
    can redefine in the first section if you don't like the default value 
    (generally 8KB). Using <B>%array</B> results in somewhat slower scanners, 
    but the value of <B>yytext</B> becomes immune to calls to <I>input()</I> and 
    <I>unput(),</I> which potentially destroy its value when <B>yytext</B> is a 
    character pointer. The opposite of <B>%array</B> is <B>%pointer,</B> which 
    is the default. 
    <DT>
    <DD>You cannot use <B>%array</B> when generating C++ scanner classes (the 
    <B>-+</B> flag). 
    <DT>-
    <DD><B>int</B> <B>yyleng</B> holds the length of the current token. 
    <DT>-
    <DD><B>FILE</B> <B>*yyin</B> is the file which by default <I>flex</I> reads 
    from. It may be redefined but doing so only makes sense before scanning 
    begins or after an EOF has been encountered. Changing it in the midst of 
    scanning will have unexpected results since <I>flex</I> buffers its input; 
    use <B>yyrestart()</B> instead. Once scanning terminates because an 
    end-of-file has been seen, you can assign <I>yyin</I> at the new input file 
    and then call the scanner again to continue scanning. 
    <DT>-
    <DD><B>void</B> <B>yyrestart(</B> <B>FILE</B> <B>*new_file</B> <B>)</B> may 
    be called to point <I>yyin</I> at the new input file. The switch-over to the 
    new file is immediate (any previously buffered-up input is lost). Note that 
    calling <B>yyrestart()</B> with <I>yyin</I> as an argument thus throws away 
    the current input buffer and continues scanning the same input file. 
    <DT>-
    <DD><B>FILE</B> <B>*yyout</B> is the file to which <B>ECHO</B> actions are 
    done. It can be reassigned by the user. 
    <DT>-
    <DD><B>YY_CURRENT_BUFFER</B> returns a <B>YY_BUFFER_STATE</B> handle to the 
    current buffer. 
    <DT>-
    <DD><B>YY_START</B> returns an integer value corresponding to the current 
    start condition. You can subsequently use this value with <B>BEGIN</B> to 
    return to that start condition. </DD></DL></UL>
<H2>INTERFACING WITH YACC </H2>
<UL>One of the main uses of <I>flex</I> is as a companion to the <I>yacc</I> 
  parser-generator. <I>yacc</I> parsers expect to call a routine named 
  <B>yylex()</B> to find the next input token. The routine is supposed to return 
  the type of the next token as well as putting any associated value in the 
  global <B>yylval.</B> To use <I>flex</I> with <I>yacc,</I> one specifies the 
  <B>-d</B> option to <I>yacc</I> to instruct it to generate the file 
  <B>y.tab.h</B> containing definitions of all the <B>%tokens</B> appearing in 
  the <I>yacc</I> input. This file is then included in the <I>flex</I> scanner. 
  For example, if one of the tokens is "TOK_NUMBER", part of the scanner might 
  look like: <PRE>
<P><BR>    %{
<BR>    #include "y.tab.h"
<BR>    %}
<BR>
<P><BR>    %%
<BR>
<P><BR>    [0-9]+        yylval = atoi( yytext ); return TOK_NUMBER;
<BR>
<P><BR></P></PRE></UL>
<H2>OPTIONS </H2>
<UL><I>flex</I> has the following options: 
  <P>
  <DL compact>
    <DT><B>-b</B> 
    <DD>Generate backing-up information to <I>lex.backup.</I> This is a list of 
    scanner states which require backing up and the input characters on which 
    they do so. By adding rules one can remove backing-up states. If <I>all</I> 
    backing-up states are eliminated and <B>-Cf</B> or <B>-CF</B> is used, the 
    generated scanner will run faster (see the <B>-p</B> flag). Only users who 
    wish to squeeze every last cycle out of their scanners need worry about this 
    option. (See the section on Performance Considerations below.) 
    <DT><B>-c</B> 
    <DD>is a do-nothing, deprecated option included for POSIX compliance. 
    <DT><B>-d</B> 
    <DD>makes the generated scanner run in <I>debug</I> mode. Whenever a pattern 
    is recognized and the global <B>yy_flex_debug</B> is non-zero (which is the 
    default), the scanner will write to <I>stderr</I> a line of the form: <PRE>
<P><BR>    --accepting rule at line 53 ("the matched text")
<BR>
<P><BR></P></PRE>The line number refers to the location of the rule in the 
    file defining the scanner (i.e., the file that was fed to flex). Messages 
    are also generated when the scanner backs up, accepts the default rule, 
    reaches the end of its input buffer (or encounters a NUL; at this point, the 
    two look the same as far as the scanner's concerned), or reaches an 
    end-of-file. 
    <DT><B>-f</B> 
    <DD>specifies <I>fast</I> <I>scanner.</I> No table compression is done and 
    stdio is bypassed. The result is large but fast. This option is equivalent 
    to <B>-Cfr</B> (see below). 
    <DT><B>-h</B> 
    <DD>generates a "help" summary of <I>flex's</I> options to <I>stdout</I> and 
    then exits. <B>-?</B> and <B>--help</B> are synonyms for <B>-h.</B> 
    <DT><B>-i</B> 
    <DD>instructs <I>flex</I> to generate a <I>case-insensitive</I> scanner. The 
    case of letters given in the <I>flex</I> input patterns will be ignored, and 
    tokens in the input will be matched regardless of case. The matched text 
    given in <I>yytext</I> will have the preserved case (i.e., it will not be 
    folded). 
    <DT><B>-l</B> 
    <DD>turns on maximum compatibility with the original AT&amp;T <I>lex</I> 
    implementation. Note that this does not mean <I>full</I> compatibility. Use 
    of this option costs a considerable amount of performance, and it cannot be 
    used with the <B>-+,</B> <B>-f,</B> <B>-F,</B> <B>-Cf,</B> or <B>-CF</B> 
    options. For details on the compatibilities it provides, see the section 
    "Incompatibilities With Lex And POSIX" below. This option also results in 
    the name <B>YY_FLEX_LEX_COMPAT</B> being #define'd in the generated scanner. 

    <DT><B>-n</B> 
    <DD>is another do-nothing, deprecated option included only for POSIX 
    compliance. 
    <DT><B>-p</B> 
    <DD>generates a performance report to stderr. The report consists of 
    comments regarding features of the <I>flex</I> input file which will cause a 
    serious loss of performance in the resulting scanner. If you give the flag 
    twice, you will also get comments regarding features that lead to minor 
    performance losses. 
    <DT>
    <DD>Note that the use of <B>REJECT,</B> <B>%option</B> <B>yylineno,</B> and 
    variable trailing context (see the Deficiencies / Bugs section below) 
    entails a substantial performance penalty; use of <I>yymore(),</I> the 
    <B>^</B> operator, and the <B>-I</B> flag entail minor performance 
    penalties. 
    <DT><B>-s</B> 
    <DD>causes the <I>default</I> <I>rule</I> (that unmatched scanner input is 
    echoed to <I>stdout)</I> to be suppressed. If the scanner encounters input 
    that does not match any of its rules, it aborts with an error. This option 
    is useful for finding holes in a scanner's rule set. 
    <DT><B>-t</B> 
    <DD>instructs <I>flex</I> to write the scanner it generates to standard 
    output instead of <B>lex.yy.c.</B> 
    <DT><B>-v</B> 
    <DD>specifies that <I>flex</I> should write to <I>stderr</I> a summary of 
    statistics regarding the scanner it generates. Most of the statistics are 
    meaningless to the casual <I>flex</I> user, but the first line identifies 
    the version of <I>flex</I> (same as reported by <B>-V),</B> and the next 
    line the flags used when generating the scanner, including those that are on 
    by default. 
    <DT><B>-w</B> 
    <DD>suppresses warning messages. 
    <DT><B>-B</B> 
    <DD>instructs <I>flex</I> to generate a <I>batch</I> scanner, the opposite 
    of <I>interactive</I> scanners generated by <B>-I</B> (see below). In 
    general, you use <B>-B</B> when you are <I>certain</I> that your scanner 
    will never be used interactively, and you want to squeeze a <I>little</I> 
    more performance out of it. If your goal is instead to squeeze out a 
    <I>lot</I> more performance, you should be using the <B>-Cf</B> or 
    <B>-CF</B> options (discussed below), which turn on <B>-B</B> automatically 
    anyway. 
    <DT><B>-F</B> 
    <DD>specifies that the fast scanner table representation should be used (and 
    stdio bypassed). This representation is about as fast as the full table 
    representation <B>(-f),</B> and for some sets of patterns will be 
    considerably smaller (and for others, larger). In general, if the pattern 
    set contains both "keywords" and a catch-all, "identifier" rule, such as in 
    the set: <PRE>
<P><BR>    "case"    return TOK_CASE;
<BR>    "switch"  return TOK_SWITCH;
<BR>    ...
<BR>    "default" return TOK_DEFAULT;
<BR>    [a-z]+    return TOK_ID;
<BR>
<P><BR></P></PRE>then you're better off using the full table representation. 
    If only the "identifier" rule is present and you then use a hash table or 
    some such to detect the keywords, you're better off using <B>-F.</B> 
    <DT>
    <DD>This option is equivalent to <B>-CFr</B> (see below). It cannot be used 
    with <B>-+.</B> 
    <DT><B>-I</B> 
    <DD>instructs <I>flex</I> to generate an <I>interactive</I> scanner. An 
    interactive scanner is one that only looks ahead to decide what token has 
    been matched if it absolutely must. It turns out that always looking one 
    extra character ahead, even if the scanner has already seen enough text to 
    disambiguate the current token, is a bit faster than only looking ahead when 
    necessary. But scanners that always look ahead give dreadful interactive 
    performance; for example, when a user types a newline, it is not recognized 
    as a newline token until they enter <I>another</I> token, which often means 
    typing in another whole line. 
    <DT>
    <DD><I>Flex</I> scanners default to <I>interactive</I> unless you use the 
    <B>-Cf</B> or <B>-CF</B> table-compression options (see below). That's 
    because if you're looking for high-performance you should be using one of 
    these options, so if you didn't, <I>flex</I> assumes you'd rather trade off 
    a bit of run-time performance for intuitive interactive behavior. Note also 
    that you <I>cannot</I> use <B>-I</B> in conjunction with <B>-Cf</B> or 
    <B>-CF.</B> Thus, this option is not really needed; it is on by default for 
    all those cases in which it is allowed. 
    <DT>
    <DD>You can force a scanner to <I>not</I> be interactive by using <B>-B</B> 
    (see above). 
    <DT><B>-L</B> 
    <DD>instructs <I>flex</I> not to generate <B>#line</B> directives. Without 
    this option, <I>flex</I> peppers the generated scanner with #line directives 
    so error messages in the actions will be correctly located with respect to 
    either the original <I>flex</I> input file (if the errors are due to code in 
    the input file), or <B>lex.yy.c</B> (if the errors are <I>flex's</I> fault 
    -- you should report these sorts of errors to the email address given 
    below). 
    <DT><B>-T</B> 
    <DD>makes <I>flex</I> run in <I>trace</I> mode. It will generate a lot of 
    messages to <I>stderr</I> concerning the form of the input and the resultant 
    non-deterministic and deterministic finite automata. This option is mostly 
    for use in maintaining <I>flex.</I> 
    <DT><B>-V</B> 
    <DD>prints the version number to <I>stdout</I> and exits. <B>--version</B> 
    is a synonym for <B>-V.</B> 
    <DT><B>-7</B> 
    <DD>instructs <I>flex</I> to generate a 7-bit scanner, i.e., one which can 
    only recognized 7-bit characters in its input. The advantage of using 
    <B>-7</B> is that the scanner's tables can be up to half the size of those 
    generated using the <B>-8</B> option (see below). The disadvantage is that 
    such scanners often hang or crash if their input contains an 8-bit 
    character. 
    <DT>
    <DD>Note, however, that unless you generate your scanner using the 
    <B>-Cf</B> or <B>-CF</B> table compression options, use of <B>-7</B> will 
    save only a small amount of table space, and make your scanner considerably 
    less portable. <I>Flex's</I> default behavior is to generate an 8-bit 
    scanner unless you use the <B>-Cf</B> or <B>-CF,</B> in which case 
    <I>flex</I> defaults to generating 7-bit scanners unless your site was 
    always configured to generate 8-bit scanners (as will often be the case with 
    non-USA sites). You can tell whether flex generated a 7-bit or an 8-bit 
    scanner by inspecting the flag summary in the <B>-v</B> output as described 
    above. 
    <DT>
    <DD>Note that if you use <B>-Cfe</B> or <B>-CFe</B> (those table compression 
    options, but also using equivalence classes as discussed see below), flex 
    still defaults to generating an 8-bit scanner, since usually with these 
    compression options full 8-bit tables are not much more expensive than 7-bit 
    tables. 
    <DT><B>-8</B> 
    <DD>instructs <I>flex</I> to generate an 8-bit scanner, i.e., one which can 
    recognize 8-bit characters. This flag is only needed for scanners generated 
    using <B>-Cf</B> or <B>-CF,</B> as otherwise flex defaults to generating an 
    8-bit scanner anyway. 
    <DT>
    <DD>See the discussion of <B>-7</B> above for flex's default behavior and 
    the tradeoffs between 7-bit and 8-bit scanners. 
    <DT><B>-+</B> 
    <DD>specifies that you want flex to generate a C++ scanner class. See the 
    section on Generating C++ Scanners below for details. 
    <DT><B>-C[aefFmr]</B> 
    <DD>controls the degree of table compression and, more generally, trade-offs 
    between small scanners and fast scanners. 
    <DT>
    <DD><B>-Ca</B> ("align") instructs flex to trade off larger tables in the 
    generated scanner for faster performance because the elements of the tables 
    are better aligned for memory access and computation. On some RISC 
    architectures, fetching and manipulating longwords is more efficient than 
    with smaller-sized units such as shortwords. This option can double the size 
    of the tables used by your scanner. 
    <DT>
    <DD><B>-Ce</B> directs <I>flex</I> to construct <I>equivalence</I> 
    <I>classes,</I> i.e., sets of characters which have identical lexical 
    properties (for example, if the only appearance of digits in the <I>flex</I> 
    input is in the character class "[0-9]" then the digits '0', '1', ..., '9' 
    will all be put in the same equivalence class). Equivalence classes usually 
    give dramatic reductions in the final table/object file sizes (typically a 
    factor of 2-5) and are pretty cheap performance-wise (one array look-up per 
    character scanned). 
    <DT>
    <DD><B>-Cf</B> specifies that the <I>full</I> scanner tables should be 
    generated - <I>flex</I> should not compress the tables by taking advantages 
    of similar transition functions for different states. 
    <DT>
    <DD><B>-CF</B> specifies that the alternate fast scanner representation 
    (described above under the <B>-F</B> flag) should be used. This option 
    cannot be used with <B>-+.</B> 
    <DT>
    <DD><B>-Cm</B> directs <I>flex</I> to construct <I>meta-equivalence</I> 
    <I>classes,</I> which are sets of equivalence classes (or characters, if 
    equivalence classes are not being used) that are commonly used together. 
    Meta-equivalence classes are often a big win when using compressed tables, 
    but they have a moderate performance impact (one or two "if" tests and one 
    array look-up per character scanned). 
    <DT>
    <DD><B>-Cr</B> causes the generated scanner to <I>bypass</I> use of the 
    standard I/O library (stdio) for input. Instead of calling <B>fread()</B> or 
    <B>getc(),</B> the scanner will use the <B>read()</B> system call, resulting 
    in a performance gain which varies from system to system, but in general is 
    probably negligible unless you are also using <B>-Cf</B> or <B>-CF.</B> 
    Using <B>-Cr</B> can cause strange behavior if, for example, you read from 
    <I>yyin</I> using stdio prior to calling the scanner (because the scanner 
    will miss whatever text your previous reads left in the stdio input buffer). 

    <DT>
    <DD><B>-Cr</B> has no effect if you define <B>YY_INPUT</B> (see The 
    Generated Scanner above). 
    <DT>
    <DD>A lone <B>-C</B> specifies that the scanner tables should be compressed 
    but neither equivalence classes nor meta-equivalence classes should be used. 

    <DT>
    <DD>The options <B>-Cf</B> or <B>-CF</B> and <B>-Cm</B> do not make sense 
    together - there is no opportunity for meta-equivalence classes if the table 
    is not being compressed. Otherwise the options may be freely mixed, and are 
    cumulative. 
    <DT>
    <DD>The default setting is <B>-Cem,</B> which specifies that <I>flex</I> 
    should generate equivalence classes and meta-equivalence classes. This 
    setting provides the highest degree of table compression. You can trade off 
    faster-executing scanners at the cost of larger tables with the following 
    generally being true: <PRE>
<P><BR>    slowest &amp; smallest
<BR>          -Cem
<BR>          -Cm
<BR>          -Ce
<BR>          -C
<BR>          -C{f,F}e
<BR>          -C{f,F}
<BR>          -C{f,F}a
<BR>    fastest &amp; largest
<BR>
<P><BR></P></PRE>Note that scanners with the smallest tables are usually 
    generated and compiled the quickest, so during development you will usually 
    want to use the default, maximal compression. 
    <DT>
    <DD><B>-Cfe</B> is often a good compromise between speed and size for 
    production scanners. 
    <DT><B>-ooutput</B> 
    <DD>directs flex to write the scanner to the file <B>output</B> instead of 
    <B>lex.yy.c.</B> If you combine <B>-o</B> with the <B>-t</B> option, then 
    the scanner is written to <I>stdout</I> but its <B>#line</B> directives (see 
    the <B>\-L</B> option above) refer to the file <B>output.</B> 
    <DT><B>-Pprefix</B> 
    <DD>changes the default <I>yy</I> prefix used by <I>flex</I> for all 
    globally-visible variable and function names to instead be <I>prefix.</I> 
    For example, <B>-Pfoo</B> changes the name of <B>yytext</B> to 
    <B>footext.</B> It also changes the name of the default output file from 
    <B>lex.yy.c</B> to <B>lex.foo.c.</B> Here are all of the names affected: <PRE>
<P><BR>    yy_create_buffer
<BR>    yy_delete_buffer
<BR>    yy_flex_debug
<BR>    yy_init_buffer
<BR>    yy_flush_buffer
<BR>    yy_load_buffer_state
<BR>    yy_switch_to_buffer
<BR>    yyin
<BR>    yyleng
<BR>    yylex
<BR>    yylineno
<BR>    yyout
<BR>    yyrestart
<BR>    yytext
<BR>    yywrap
<BR>
<P><BR></P></PRE>(If you are using a C++ scanner, then only <B>yywrap</B> 
    and <B>yyFlexLexer</B> are affected.) Within your scanner itself, you can 
    still refer to the global variables and functions using either version of 
    their name; but externally, they have the modified name. 
    <DT>
    <DD>This option lets you easily link together multiple <I>flex</I> programs 
    into the same executable. Note, though, that using this option also renames 
    <B>yywrap(),</B> so you now <I>must</I> either provide your own 
    (appropriately-named) version of the routine for your scanner, or use 
    <B>%option</B> <B>noyywrap,</B> as linking with <B>-lfl</B> no longer 
    provides one for you by default. 
    <DT><B>-Sskeleton_file</B> 
    <DD>overrides the default skeleton file from which <I>flex</I> constructs 
    its scanners. You'll never need this option unless you are doing <I>flex</I> 
    maintenance or development. </DD></DL>
  <P><I>flex</I> also provides a mechanism for controlling options within the 
  scanner specification itself, rather than from the flex command-line. This is 
  done by including <B>%option</B> directives in the first section of the 
  scanner specification. You can specify multiple options with a single 
  <B>%option</B> directive, and multiple directives in the first section of your 
  flex input file. Most options are given simply as names, optionally preceded 
  by the word "no" (with no intervening whitespace) to negate their meaning. A 
  number are equivalent to flex flags or their negation: <PRE>
<P><BR>    7bit            -7 option
<BR>    8bit            -8 option
<BR>    align           -Ca option
<BR>    backup          -b option
<BR>    batch           -B option
<BR>    c++             -+ option
<BR>
<P><BR>    caseful or
<BR>    case-sensitive  opposite of -i (default)
<BR>
<P><BR>    case-insensitive or
<BR>    caseless        -i option
<BR>
<P><BR>    debug           -d option
<BR>    default         opposite of -s option
<BR>    ecs             -Ce option
<BR>    fast            -F option
<BR>    full            -f option
<BR>    interactive     -I option
<BR>    lex-compat      -l option
<BR>    meta-ecs        -Cm option
<BR>    perf-report     -p option
<BR>    read            -Cr option
<BR>    stdout          -t option
<BR>    verbose         -v option
<BR>    warn            opposite of -w option
<BR>                    (use "%option nowarn" for -w)
<BR>
<P><BR>    array           equivalent to "%array"
<BR>    pointer         equivalent to "%pointer" (default)
<BR>
<P><BR></P></PRE>Some <B>%option's</B> provide features otherwise not 
  available: 
  <P>
  <DL compact>
    <DT><B>always-interactive</B> 
    <DD>instructs flex to generate a scanner which always considers its input 
    "interactive". Normally, on each new input file the scanner calls 
    <B>isatty()</B> in an attempt to determine whether the scanner's input 
    source is interactive and thus should be read a character at a time. When 
    this option is used, however, then no such call is made. 
    <DT><B>main</B> 
    <DD>directs flex to provide a default <B>main()</B> program for the scanner, 
    which simply calls <B>yylex().</B> This option implies <B>noyywrap</B> (see 
    below). 
    <DT><B>never-interactive</B> 
    <DD>instructs flex to generate a scanner which never considers its input 
    "interactive" (again, no call made to <B>isatty()).</B> This is the opposite 
    of <B>always-interactive.</B> 
    <DT><B>stack</B> 
    <DD>enables the use of start condition stacks (see Start Conditions above). 
    <DT><B>stdinit</B> 
    <DD>if unset (i.e., <B>%option</B> <B>nostdinit)</B> initializes <I>yyin</I> 
    and <I>yyout</I> to nil <I>FILE</I> pointers, instead of <I>stdin</I> and 
    <I>stdout.</I> 
    <DT><B>yylineno</B> 
    <DD>directs <I>flex</I> to generate a scanner that maintains the number of 
    the current line read from its input in the global variable <B>yylineno.</B> 
    This option is implied by <B>%option</B> <B>lex-compat.</B> 
    <DT><B>yywrap</B> 
    <DD>if unset (i.e., <B>%option</B> <B>noyywrap),</B> makes the scanner not 
    call <B>yywrap()</B> upon an end-of-file, but simply assume that there are 
    no more files to scan (until the user points <I>yyin</I> at a new file and 
    calls <B>yylex()</B> again). </DD></DL>
  <P><I>flex</I> scans your rule actions to determine whether you use the 
  <B>REJECT</B> or <B>yymore()</B> features. The <B>reject</B> and <B>yymore</B> 
  options are available to override its decision as to whether you use the 
  options, either by setting them (e.g., <B>%option</B> <B>reject)</B> to 
  indicate the feature is indeed used, or unsetting them to indicate it actually 
  is not used (e.g., <B>%option</B> <B>noyymore).</B> 
  <P>Three options take string-delimited values, offset with '=': <PRE>
<P><BR>    %option outfile="ABC"
<BR>
<P><BR></P></PRE>is equivalent to <B>-oABC,</B> and <PRE>
<P><BR>    %option prefix="XYZ"
<BR>
<P><BR></P></PRE>is equivalent to <B>-PXYZ.</B> Finally, <PRE>
<P><BR>    %option yyclass="foo"
<BR>
<P><BR></P></PRE>only applies when generating a C++ scanner ( <B>-+</B> 
  option). It informs <I>flex</I> that you have derived <B>foo</B> as a subclass 
  of <B>yyFlexLexer,</B> so <I>flex</I> will place your actions in the member 
  function <B>foo::yylex()</B> instead of <B>yyFlexLexer::yylex().</B> It also 
  generates a <B>yyFlexLexer::yylex()</B> member function that emits a run-time 
  error (by invoking <B>yyFlexLexer::LexerError())</B> if called. See Generating 
  C++ Scanners, below, for additional information. 
  <P>A number of options are available for lint purists who want to suppress the 
  appearance of unneeded routines in the generated scanner. Each of the 
  following, if unset, results in the corresponding routine not appearing in the 
  generated scanner: <PRE>
<P><BR>    input, unput
<BR>    yy_push_state, yy_pop_state, yy_top_state
<BR>    yy_scan_buffer, yy_scan_bytes, yy_scan_string
<BR>
<P><BR></P></PRE>(though <B>yy_push_state()</B> and friends won't appear 
  anyway unless you use <B>%option</B> <B>stack).</B> </UL>
<H2>PERFORMANCE CONSIDERATIONS </H2>
<UL>The main design goal of <I>flex</I> is that it generate high-performance 
  scanners. It has been optimized for dealing well with large sets of rules. 
  Aside from the effects on scanner speed of the table compression <B>-C</B> 
  options outlined above, there are a number of options/actions which degrade 
  performance. These are, from most expensive to least: <PRE>
<P><BR>    REJECT
<BR>    %option yylineno
<BR>    arbitrary trailing context
<BR>
<P><BR>    pattern sets that require backing up
<BR>    %array
<BR>    %option interactive
<BR>    %option always-interactive
<BR>
<P><BR>    '^' beginning-of-line operator
<BR>    yymore()
<BR>
<P><BR></P></PRE>with the first three all being quite expensive and the last 
  two being quite cheap. Note also that <B>unput()</B> is implemented as a 
  routine call that potentially does quite a bit of work, while <B>yyless()</B> 
  is a quite-cheap macro; so if just putting back some excess text you scanned, 
  use <B>yyless().</B> 
  <P><B>REJECT</B> should be avoided at all costs when performance is important. 
  It is a particularly expensive option. 
  <P>Getting rid of backing up is messy and often may be an enormous amount of 
  work for a complicated scanner. In principal, one begins by using the 
  <B>-b</B> flag to generate a <I>lex.backup</I> file. For example, on the input 
<PRE>
<P><BR>    %%
<BR>    foo        return TOK_KEYWORD;
<BR>    foobar     return TOK_KEYWORD;
<BR>
<P><BR></P></PRE>the file looks like: <PRE>
<P><BR>    State #6 is non-accepting -
<BR>     associated rule line numbers:
<BR>           2       3
<BR>     out-transitions: [ o ]
<BR>     jam-transitions: EOF [ \001-n  p-\177 ]
<BR>
<P><BR>    State #8 is non-accepting -
<BR>     associated rule line numbers:
<BR>           3
<BR>     out-transitions: [ a ]
<BR>     jam-transitions: EOF [ \001-`  b-\177 ]
<BR>
<P><BR>    State #9 is non-accepting -
<BR>     associated rule line numbers:
<BR>           3
<BR>     out-transitions: [ r ]
<BR>     jam-transitions: EOF [ \001-q  s-\177 ]
<BR>
<P><BR>    Compressed tables always back up.
<BR>
<P><BR></P></PRE>The first few lines tell us that there's a scanner state in 
  which it can make a transition on an 'o' but not on any other character, and 
  that in that state the currently scanned text does not match any rule. The 
  state occurs when trying to match the rules found at lines 2 and 3 in the 
  input file. If the scanner is in that state and then reads something other 
  than an 'o', it will have to back up to find a rule which is matched. With a 
  bit of headscratching one can see that this must be the state it's in when it 
  has seen "fo". When this has happened, if anything other than another 'o' is 
  seen, the scanner will have to back up to simply match the 'f' (by the default 
  rule). 
  <P>The comment regarding State #8 indicates there's a problem when "foob" has 
  been scanned. Indeed, on any character other than an 'a', the scanner will 
  have to back up to accept "foo". Similarly, the comment for State #9 concerns 
  when "fooba" has been scanned and an 'r' does not follow. 
  <P>The final comment reminds us that there's no point going to all the trouble 
  of removing backing up from the rules unless we're using <B>-Cf</B> or 
  <B>-CF,</B> since there's no performance gain doing so with compressed 
  scanners. 
  <P>The way to remove the backing up is to add "error" rules: <PRE>
<P><BR>    %%
<BR>    foo         return TOK_KEYWORD;
<BR>    foobar      return TOK_KEYWORD;
<BR>
<P><BR>    fooba       |
<BR>    foob        |
<BR>    fo          {
<BR>                /* false alarm, not really a keyword */
<BR>                return TOK_ID;
<BR>                }
<BR>
<P><BR></P></PRE>
  <P>Eliminating backing up among a list of keywords can also be done using a 
  "catch-all" rule: <PRE>
<P><BR>    %%
<BR>    foo         return TOK_KEYWORD;
<BR>    foobar      return TOK_KEYWORD;
<BR>
<P><BR>    [a-z]+      return TOK_ID;
<BR>
<P><BR></P></PRE>This is usually the best solution when appropriate. 
  <P>Backing up messages tend to cascade. With a complicated set of rules it's 
  not uncommon to get hundreds of messages. If one can decipher them, though, it 
  often only takes a dozen or so rules to eliminate the backing up (though it's 
  easy to make a mistake and have an error rule accidentally match a valid 
  token. A possible future <I>flex</I> feature will be to automatically add 
  rules to eliminate backing up). 
  <P>It's important to keep in mind that you gain the benefits of eliminating 
  backing up only if you eliminate <I>every</I> instance of backing up. Leaving 
  just one means you gain nothing. 
  <P><I>Variable</I> trailing context (where both the leading and trailing parts 
  do not have a fixed length) entails almost the same performance loss as 
  <B>REJECT</B> (i.e., substantial). So when possible a rule like: <PRE>
<P><BR>    %%
<BR>    mouse|rat/(cat|dog)   run();
<BR>
<P><BR></P></PRE>is better written: <PRE>
<P><BR>    %%
<BR>    mouse/cat|dog         run();
<BR>    rat/cat|dog           run();
<BR>
<P><BR></P></PRE>or as <PRE>
<P><BR>    %%
<BR>    mouse|rat/cat         run();
<BR>    mouse|rat/dog         run();
<BR>
<P><BR></P></PRE>Note that here the special '|' action does <I>not</I> provide 
  any savings, and can even make things worse (see Deficiencies / Bugs below). 
  <P>Another area where the user can increase a scanner's performance (and one 
  that's easier to implement) arises from the fact that the longer the tokens 
  matched, the faster the scanner will run. This is because with long tokens the 
  processing of most input characters takes place in the (short) inner scanning 
  loop, and does not often have to go through the additional work of setting up 
  the scanning environment (e.g., <B>yytext)</B> for the action. Recall the 
  scanner for C comments: <PRE>
<P><BR>    %x comment
<BR>    %%
<BR>            int line_num = 1;
<BR>
<P><BR>    "/*"         BEGIN(comment);
<BR>
<P><BR>    &lt;comment&gt;[^*\n]*
<BR>    &lt;comment&gt;"*"+[^*/\n]*
<BR>    &lt;comment&gt;\n             ++line_num;
<BR>    &lt;comment&gt;"*"+"/"        BEGIN(INITIAL);
<BR>
<P><BR></P></PRE>This could be sped up by writing it as: <PRE>
<P><BR>    %x comment
<BR>    %%
<BR>            int line_num = 1;
<BR>
<P><BR>    "/*"         BEGIN(comment);
<BR>
<P><BR>    &lt;comment&gt;[^*\n]*
<BR>    &lt;comment&gt;[^*\n]*\n      ++line_num;
<BR>    &lt;comment&gt;"*"+[^*/\n]*
<BR>    &lt;comment&gt;"*"+[^*/\n]*\n ++line_num;
<BR>    &lt;comment&gt;"*"+"/"        BEGIN(INITIAL);
<BR>
<P><BR></P></PRE>Now instead of each newline requiring the processing of 
  another action, recognizing the newlines is "distributed" over the other rules 
  to keep the matched text as long as possible. Note that <I>adding</I> rules 
  does <I>not</I> slow down the scanner! The speed of the scanner is independent 
  of the number of rules or (modulo the considerations given at the beginning of 
  this section) how complicated the rules are with regard to operators such as 
  '*' and '|'. 
  <P>A final example in speeding up a scanner: suppose you want to scan through 
  a file containing identifiers and keywords, one per line and with no other 
  extraneous characters, and recognize all the keywords. A natural first 
  approach is: <PRE>
<P><BR>    %%
<BR>    asm      |
<BR>    auto     |
<BR>    break    |
<BR>    ... etc ...
<BR>    volatile |
<BR>    while    /* it's a keyword */
<BR>
<P><BR>    .|\n     /* it's not a keyword */
<BR>
<P><BR></P></PRE>To eliminate the back-tracking, introduce a catch-all rule: <PRE>
<P><BR>    %%
<BR>    asm      |
<BR>    auto     |
<BR>    break    |
<BR>    ... etc ...
<BR>    volatile |
<BR>    while    /* it's a keyword */
<BR>
<P><BR>    [a-z]+   |
<BR>    .|\n     /* it's not a keyword */
<BR>
<P><BR></P></PRE>Now, if it's guaranteed that there's exactly one word per 
  line, then we can reduce the total number of matches by a half by merging in 
  the recognition of newlines with that of the other tokens: <PRE>
<P><BR>    %%
<BR>    asm\n    |
<BR>    auto\n   |
<BR>    break\n  |
<BR>    ... etc ...
<BR>    volatile\n |
<BR>    while\n  /* it's a keyword */
<BR>
<P><BR>    [a-z]+\n |
<BR>    .|\n     /* it's not a keyword */
<BR>
<P><BR></P></PRE>One has to be careful here, as we have now reintroduced 
  backing up into the scanner. In particular, while <I>we</I> know that there 
  will never be any characters in the input stream other than letters or 
  newlines, <I>flex</I> can't figure this out, and it will plan for possibly 
  needing to back up when it has scanned a token like "auto" and then the next 
  character is something other than a newline or a letter. Previously it would 
  then just match the "auto" rule and be done, but now it has no "auto" rule, 
  only a "auto\n" rule. To eliminate the possibility of backing up, we could 
  either duplicate all rules but without final newlines, or, since we never 
  expect to encounter such an input and therefore don't how it's classified, we 
  can introduce one more catch-all rule, this one which doesn't include a 
  newline: <PRE>
<P><BR>    %%
<BR>    asm\n    |
<BR>    auto\n   |
<BR>    break\n  |
<BR>    ... etc ...
<BR>    volatile\n |
<BR>    while\n  /* it's a keyword */
<BR>
<P><BR>    [a-z]+\n |
<BR>    [a-z]+   |
<BR>    .|\n     /* it's not a keyword */
<BR>
<P><BR></P></PRE>Compiled with <B>-Cf,</B> this is about as fast as one can 
  get a <I>flex</I> scanner to go for this particular problem. 
  <P>A final note: <I>flex</I> is slow when matching NUL's, particularly when a 
  token contains multiple NUL's. It's best to write rules which match 
  <I>short</I> amounts of text if it's anticipated that the text will often 
  include NUL's. 
  <P>Another final note regarding performance: as mentioned above in the section 
  How the Input is Matched, dynamically resizing <B>yytext</B> to accommodate 
  huge tokens is a slow process because it presently requires that the (huge) 
  token be rescanned from the beginning. Thus if performance is vital, you 
  should attempt to match "large" quantities of text but not "huge" quantities, 
  where the cutoff between the two is at about 8K characters/token. </P></UL>
<H2>GENERATING C++ SCANNERS </H2>
<UL><I>flex</I> provides two different ways to generate scanners for use with 
  C++. The first way is to simply compile a scanner generated by <I>flex</I> 
  using a C++ compiler instead of a C compiler. You should not encounter any 
  compilations errors (please report any you find to the email address given in 
  the Author section below). You can then use C++ code in your rule actions 
  instead of C code. Note that the default input source for your scanner remains 
  <I>yyin,</I> and default echoing is still done to <I>yyout.</I> Both of these 
  remain <I>FILE</I> <I>*</I> variables and not C++ <I>streams.</I> 
  <P>You can also use <I>flex</I> to generate a C++ scanner class, using the 
  <B>-+</B> option (or, equivalently, <B>%option</B> <B>c++),</B> which is 
  automatically specified if the name of the flex executable ends in a '+', such 
  as <I>flex++.</I> When using this option, flex defaults to generating the 
  scanner to the file <B>lex.yy.cc</B> instead of <B>lex.yy.c.</B> The generated 
  scanner includes the header file <I>FlexLexer.h,</I> which defines the 
  interface to two C++ classes. 
  <P>The first class, <B>FlexLexer,</B> provides an abstract base class defining 
  the general scanner class interface. It provides the following member 
  functions: 
  <P>
  <DL compact>
    <DT><B>const</B> <B>char*</B> <B>YYText()</B> 
    <DD>returns the text of the most recently matched token, the equivalent of 
    <B>yytext.</B> 
    <DT><B>int</B> <B>YYLeng()</B> 
    <DD>returns the length of the most recently matched token, the equivalent of 
    <B>yyleng.</B> 
    <DT><B>int</B> <B>lineno()</B> <B>const</B> 
    <DD>returns the current input line number (see <B>%option</B> 
    <B>yylineno),</B> or <B>1</B> if <B>%option</B> <B>yylineno</B> was not 
    used. 
    <DT><B>void</B> <B>set_debug(</B> <B>int</B> <B>flag</B> <B>)</B> 
    <DD>sets the debugging flag for the scanner, equivalent to assigning to 
    <B>yy_flex_debug</B> (see the Options section above). Note that you must 
    build the scanner using <B>%option</B> <B>debug</B> to include debugging 
    information in it. 
    <DT><B>int</B> <B>debug()</B> <B>const</B> 
    <DD>returns the current setting of the debugging flag. </DD></DL>
  <P>Also provided are member functions equivalent to 
  <B>yy_switch_to_buffer(),</B> <B>yy_create_buffer()</B> (though the first 
  argument is an <B>istream*</B> object pointer and not a <B>FILE*),</B> 
  <B>yy_flush_buffer(),</B> <B>yy_delete_buffer(),</B> and <B>yyrestart()</B> 
  (again, the first argument is a <B>istream*</B> object pointer). 
  <P>The second class defined in <I>FlexLexer.h</I> is <B>yyFlexLexer,</B> which 
  is derived from <B>FlexLexer.</B> It defines the following additional member 
  functions: 
  <P>
  <DL compact>
    <DT><B>yyFlexLexer( istream* arg_yyin = 0, ostream* arg_yyout = 0 ) </B>
    <DD>constructs a <B>yyFlexLexer</B> object using the given streams for input 
    and output. If not specified, the streams default to <B>cin</B> and 
    <B>cout,</B> respectively. 
    <DT><B>virtual</B> <B>int</B> <B>yylex()</B> 
    <DD>performs the same role is <B>yylex()</B> does for ordinary flex 
    scanners: it scans the input stream, consuming tokens, until a rule's action 
    returns a value. If you derive a subclass <B>S</B> from <B>yyFlexLexer</B> 
    and want to access the member functions and variables of <B>S</B> inside 
    <B>yylex(),</B> then you need to use <B>%option</B> <B>yyclass=S</B> to 
    inform <I>flex</I> that you will be using that subclass instead of 
    <B>yyFlexLexer.</B> In this case, rather than generating 
    <B>yyFlexLexer::yylex(),</B> <I>flex</I> generates <B>S::yylex()</B> (and 
    also generates a dummy <B>yyFlexLexer::yylex()</B> that calls 
    <B>yyFlexLexer::LexerError()</B> if called). 
    <DT><B>virtual void switch_streams(istream* new_in = 0, </B><B>
    <DD>ostream* new_out = 0) </B>reassigns <B>yyin</B> to <B>new_in</B> (if 
    non-nil) and <B>yyout</B> to <B>new_out</B> (ditto), deleting the previous 
    input buffer if <B>yyin</B> is reassigned. 
    <DT><B>int yylex( istream* new_in = 0, ostream* new_out = 0 ) </B>
    <DD>first switches the input streams via <B>switch_streams(</B> 
    <B>new_in,</B> <B>new_out</B> <B>)</B> and then returns the value of 
    <B>yylex().</B> </DD></DL>
  <P>In addition, <B>yyFlexLexer</B> defines the following protected virtual 
  functions which you can redefine in derived classes to tailor the scanner: 
  <P>
  <DL compact>
    <DT><B>virtual int LexerInput( char* buf, int max_size ) </B>
    <DD>reads up to <B>max_size</B> characters into <B>buf</B> and returns the 
    number of characters read. To indicate end-of-input, return 0 characters. 
    Note that "interactive" scanners (see the <B>-B</B> and <B>-I</B> flags) 
    define the macro <B>YY_INTERACTIVE.</B> If you redefine <B>LexerInput()</B> 
    and need to take different actions depending on whether or not the scanner 
    might be scanning an interactive input source, you can test for the presence 
    of this name via <B>#ifdef.</B> 
    <DT><B>virtual void LexerOutput( const char* buf, int size ) </B>
    <DD>writes out <B>size</B> characters from the buffer <B>buf,</B> which, 
    while NUL-terminated, may also contain "internal" NUL's if the scanner's 
    rules can match text with NUL's in them. 
    <DT><B>virtual void LexerError( const char* msg ) </B>
    <DD>reports a fatal error message. The default version of this function 
    writes the message to the stream <B>cerr</B> and exits. </DD></DL>
  <P>Note that a <B>yyFlexLexer</B> object contains its <I>entire</I> scanning 
  state. Thus you can use such objects to create reentrant scanners. You can 
  instantiate multiple instances of the same <B>yyFlexLexer</B> class, and you 
  can also combine multiple C++ scanner classes together in the same program 
  using the <B>-P</B> option discussed above. 
  <P>Finally, note that the <B>%array</B> feature is not available to C++ 
  scanner classes; you must use <B>%pointer</B> (the default). 
  <P>Here is an example of a simple C++ scanner: <PRE>
<P><BR>        // An example of using the flex C++ scanner class.
<BR>
<P><BR>    %{
<BR>    int mylineno = 0;
<BR>    %}
<BR>
<P><BR>    string  \"[^\n"]+\"
<BR>
<P><BR>    ws      [ \t]+
<BR>
<P><BR>    alpha   [A-Za-z]
<BR>    dig     [0-9]
<BR>    name    ({alpha}|{dig}|\$)({alpha}|{dig}|[_.\-/$])*
<BR>    num1    [-+]?{dig}+\.?([eE][-+]?{dig}+)?
<BR>    num2    [-+]?{dig}*\.{dig}+([eE][-+]?{dig}+)?
<BR>    number  {num1}|{num2}
<BR>
<P><BR>    %%
<BR>
<P><BR>    {ws}    /* skip blanks and tabs */
<BR>
<P><BR>    "/*"    {
<BR>            int c;
<BR>
<P><BR>            while((c = yyinput()) != 0)
<BR>                {
<BR>                if(c == '\n')
<BR>                    ++mylineno;
<BR>
<P><BR>                else if(c == '*')
<BR>                    {
<BR>                    if((c = yyinput()) == '/')
<BR>                        break;
<BR>                    else
<BR>                        unput(c);
<BR>                    }
<BR>                }
<BR>            }
<BR>
<P><BR>    {number}  cout &lt;&lt; "number " &lt;&lt; YYText() &lt;&lt; '\n';
<BR>
<P><BR>    \n        mylineno++;
<BR>
<P><BR>    {name}    cout &lt;&lt; "name " &lt;&lt; YYText() &lt;&lt; '\n';
<BR>
<P><BR>    {string}  cout &lt;&lt; "string " &lt;&lt; YYText() &lt;&lt; '\n';
<BR>
<P><BR>    %%
<BR>
<P><BR>    int main( int /* argc */, char** /* argv */ )
<BR>        {
<BR>        FlexLexer* lexer = new yyFlexLexer;
<BR>        while(lexer-&gt;yylex() != 0)
<BR>            ;
<BR>        return 0;
<BR>        }
<BR></P></PRE>If you want to create multiple (different) lexer classes, you 
  use the <B>-P</B> flag (or the <B>prefix=</B> option) to rename each 
  <B>yyFlexLexer</B> to some other <B>xxFlexLexer.</B> You then can include 
  <B>&lt;FlexLexer.h&gt;</B> in your other sources once per lexer class, first 
  renaming <B>yyFlexLexer</B> as follows: <PRE>
<P><BR>    #undef yyFlexLexer
<BR>    #define yyFlexLexer xxFlexLexer
<BR>    #include &lt;FlexLexer.h&gt;
<BR>
<P><BR>    #undef yyFlexLexer
<BR>    #define yyFlexLexer zzFlexLexer
<BR>    #include &lt;FlexLexer.h&gt;
<BR>
<P><BR></P></PRE>if, for example, you used <B>%option</B> <B>prefix=xx</B> for 
  one of your scanners and <B>%option</B> <B>prefix=zz</B> for the other. 
  <P>IMPORTANT: the present form of the scanning class is <I>experimental</I> 
  and may change considerably between major releases. </P></UL>
<H2>INCOMPATIBILITIES WITH LEX AND POSIX </H2>
<UL><I>flex</I> is a rewrite of the AT&amp;T Unix <I>lex</I> tool (the two 
  implementations do not share any code, though), with some extensions and 
  incompatibilities, both of which are of concern to those who wish to write 
  scanners acceptable to either implementation. Flex is fully compliant with the 
  POSIX <I>lex</I> specification, except that when using <B>%pointer</B> (the 
  default), a call to <B>unput()</B> destroys the contents of <B>yytext,</B> 
  which is counter to the POSIX specification. 
  <P>In this section we discuss all of the known areas of incompatibility 
  between flex, AT&amp;T lex, and the POSIX specification. 
  <P><I>flex's</I> <B>-l</B> option turns on maximum compatibility with the 
  original AT&amp;T <I>lex</I> implementation, at the cost of a major loss in 
  the generated scanner's performance. We note below which incompatibilities can 
  be overcome using the <B>-l</B> option. 
  <P><I>flex</I> is fully compatible with <I>lex</I> with the following 
  exceptions: 
  <P>
  <DL compact>
    <DT>-
    <DD>The undocumented <I>lex</I> scanner internal variable <B>yylineno</B> is 
    not supported unless <B>-l</B> or <B>%option</B> <B>yylineno</B> is used. 
    <DT>
    <DD><B>yylineno</B> should be maintained on a per-buffer basis, rather than 
    a per-scanner (single global variable) basis. 
    <DT>
    <DD><B>yylineno</B> is not part of the POSIX specification. 
    <DT>-
    <DD>The <B>input()</B> routine is not redefinable, though it may be called 
    to read characters following whatever has been matched by a rule. If 
    <B>input()</B> encounters an end-of-file the normal <B>yywrap()</B> 
    processing is done. A ``real'' end-of-file is returned by <B>input()</B> as 
    <I>EOF.</I> 
    <DT>
    <DD>Input is instead controlled by defining the <B>YY_INPUT</B> macro. 
    <DT>
    <DD>The <I>flex</I> restriction that <B>input()</B> cannot be redefined is 
    in accordance with the POSIX specification, which simply does not specify 
    any way of controlling the scanner's input other than by making an initial 
    assignment to <I>yyin.</I> 
    <DT>-
    <DD>The <B>unput()</B> routine is not redefinable. This restriction is in 
    accordance with POSIX. 
    <DT>-
    <DD><I>flex</I> scanners are not as reentrant as <I>lex</I> scanners. In 
    particular, if you have an interactive scanner and an interrupt handler 
    which long-jumps out of the scanner, and the scanner is subsequently called 
    again, you may get the following message: <PRE>
<P><BR>    fatal flex scanner internal error--end of buffer missed
<BR>
<P><BR></P></PRE>To reenter the scanner, first use <PRE>
<P><BR>    yyrestart( yyin );
<BR>
<P><BR></P></PRE>Note that this call will throw away any buffered input; 
    usually this isn't a problem with an interactive scanner. 
    <DT>
    <DD>Also note that flex C++ scanner classes <I>are</I> reentrant, so if 
    using C++ is an option for you, you should use them instead. See "Generating 
    C++ Scanners" above for details. 
    <DT>-
    <DD><B>output()</B> is not supported. Output from the <B>ECHO</B> macro is 
    done to the file-pointer <I>yyout</I> (default <I>stdout).</I> 
    <DT>
    <DD><B>output()</B> is not part of the POSIX specification. 
    <DT>-
    <DD><I>lex</I> does not support exclusive start conditions (%x), though they 
    are in the POSIX specification. 
    <DT>-
    <DD>When definitions are expanded, <I>flex</I> encloses them in parentheses. 
    With lex, the following: <PRE>
<P><BR>    NAME    [A-Z][A-Z0-9]*
<BR>    %%
<BR>    foo{NAME}?      printf( "Found it\n" );
<BR>    %%
<BR>
<P><BR></P></PRE>will not match the string "foo" because when the macro is 
    expanded the rule is equivalent to "foo[A-Z][A-Z0-9]*?" and the precedence 
    is such that the '?' is associated with "[A-Z0-9]*". With <I>flex,</I> the 
    rule will be expanded to "foo([A-Z][A-Z0-9]*)?" and so the string "foo" will 
    match. 
    <DT>
    <DD>Note that if the definition begins with <B>^</B> or ends with <B>$</B> 
    then it is <I>not</I> expanded with parentheses, to allow these operators to 
    appear in definitions without losing their special meanings. But the 
    <B>&lt;s&gt;,</B> <B>/,</B> and <B>&lt;&lt;EOF&gt;&gt;</B> operators cannot 
    be used in a <I>flex</I> definition. 
    <DT>
    <DD>Using <B>-l</B> results in the <I>lex</I> behavior of no parentheses 
    around the definition. 
    <DT>
    <DD>The POSIX specification is that the definition be enclosed in 
    parentheses. 
    <DT>-
    <DD>Some implementations of <I>lex</I> allow a rule's action to begin on a 
    separate line, if the rule's pattern has trailing whitespace: <PRE>
<P><BR>    %%
<BR>    foo|bar&lt;space here&gt;
<BR>      { foobar_action(); }
<BR>
<P><BR></P></PRE><I>flex</I> does not support this feature. 
    <DT>-
    <DD>The <I>lex</I> <B>%r</B> (generate a Ratfor scanner) option is not 
    supported. It is not part of the POSIX specification. 
    <DT>-
    <DD>After a call to <B>unput(),</B> <I>yytext</I> is undefined until the 
    next token is matched, unless the scanner was built using <B>%array.</B> 
    This is not the case with <I>lex</I> or the POSIX specification. The 
    <B>-l</B> option does away with this incompatibility. 
    <DT>-
    <DD>The precedence of the <B>{}</B> (numeric range) operator is different. 
    <I>lex</I> interprets "abc{1,3}" as "match one, two, or three occurrences of 
    'abc'", whereas <I>flex</I> interprets it as "match 'ab' followed by one, 
    two, or three occurrences of 'c'". The latter is in agreement with the POSIX 
    specification. 
    <DT>-
    <DD>The precedence of the <B>^</B> operator is different. <I>lex</I> 
    interprets "^foo|bar" as "match either 'foo' at the beginning of a line, or 
    'bar' anywhere", whereas <I>flex</I> interprets it as "match either 'foo' or 
    'bar' if they come at the beginning of a line". The latter is in agreement 
    with the POSIX specification. 
    <DT>-
    <DD>The special table-size declarations such as <B>%a</B> supported by 
    <I>lex</I> are not required by <I>flex</I> scanners; <I>flex</I> ignores 
    them. 
    <DT>-
    <DD>The name FLEX_SCANNER is #define'd so scanners may be written for use 
    with either <I>flex</I> or <I>lex.</I> Scanners also include 
    <B>YY_FLEX_MAJOR_VERSION</B> and <B>YY_FLEX_MINOR_VERSION</B> indicating 
    which version of <I>flex</I> generated the scanner (for example, for the 2.5 
    release, these defines would be 2 and 5 respectively). </DD></DL>
  <P>The following <I>flex</I> features are not included in <I>lex</I> or the 
  POSIX specification: <PRE>
<P><BR>    C++ scanners
<BR>    %option
<BR>    start condition scopes
<BR>    start condition stacks
<BR>    interactive/non-interactive scanners
<BR>    yy_scan_string() and friends
<BR>    yyterminate()
<BR>    yy_set_interactive()
<BR>    yy_set_bol()
<BR>    YY_AT_BOL()
<BR>    &lt;&lt;EOF&gt;&gt;
<BR>    &lt;*&gt;
<BR>    YY_DECL
<BR>    YY_START
<BR>    YY_USER_ACTION
<BR>    YY_USER_INIT
<BR>    #line directives
<BR>    %{}'s around actions
<BR>    multiple actions on a line
<BR>
<P><BR></P></PRE>plus almost all of the flex flags. The last feature in the 
  list refers to the fact that with <I>flex</I> you can put multiple actions on 
  the same line, separated with semi-colons, while with <I>lex,</I> the 
  following <PRE>
<P><BR>    foo    handle_foo(); ++num_foos_seen;
<BR>
<P><BR></P></PRE>is (rather surprisingly) truncated to <PRE>
<P><BR>    foo    handle_foo();
<BR>
<P><BR></P></PRE><I>flex</I> does not truncate the action. Actions that are 
  not enclosed in braces are simply terminated at the end of the line. </UL>
<H2>DIAGNOSTICS </H2>
<UL>
  <P><I>warning,</I> <I>rule</I> <I>cannot</I> <I>be</I> <I>matched</I> 
  indicates that the given rule cannot be matched because it follows other rules 
  that will always match the same text as it. For example, in the following 
  "foo" cannot be matched because it comes after an identifier "catch-all" rule: 
<PRE>
<P><BR>    [a-z]+    got_identifier();
<BR>    foo       got_foo();
<BR>
<P><BR></P></PRE>Using <B>REJECT</B> in a scanner suppresses this warning. 
  <P><I>warning,</I> <B>-s</B> <I>option given but default rule can be matched 
  </I>means that it is possible (perhaps only in a particular start condition) 
  that the default rule (match any single character) is the only one that will 
  match a particular input. Since <B>-s</B> was given, presumably this is not 
  intended. 
  <P><I>reject_used_but_not_detected</I> <I>undefined</I> or 
  <I>yymore_used_but_not_detected</I> <I>undefined</I> <I>-</I> These errors can 
  occur at compile time. They indicate that the scanner uses <B>REJECT</B> or 
  <B>yymore()</B> but that <I>flex</I> failed to notice the fact, meaning that 
  <I>flex</I> scanned the first two sections looking for occurrences of these 
  actions and failed to find any, but somehow you snuck some in (via a #include 
  file, for example). Use <B>%option</B> <B>reject</B> or <B>%option</B> 
  <B>yymore</B> to indicate to flex that you really do use these features. 
  <P><I>flex</I> <I>scanner</I> <I>jammed</I> <I>-</I> a scanner compiled with 
  <B>-s</B> has encountered an input string which wasn't matched by any of its 
  rules. This error can also occur due to internal problems. 
  <P><I>token</I> <I>too</I> <I>large,</I> <I>exceeds</I> <I>YYLMAX</I> <I>-</I> 
  your scanner uses <B>%array</B> and one of its rules matched a string longer 
  than the <B>YYLMAX</B> constant (8K bytes by default). You can increase the 
  value by #define'ing <B>YYLMAX</B> in the definitions section of your 
  <I>flex</I> input. 
  <P><I>scanner</I> <I>requires</I> <I>-8</I> <I>flag</I> <I>to</I> <I>use</I> 
  <I>the</I> <I>character</I> <I>'x'</I> <I>-</I> Your scanner specification 
  includes recognizing the 8-bit character <I>'x'</I> and you did not specify 
  the -8 flag, and your scanner defaulted to 7-bit because you used the 
  <B>-Cf</B> or <B>-CF</B> table compression options. See the discussion of the 
  <B>-7</B> flag for details. 
  <P><I>flex</I> <I>scanner</I> <I>push-back</I> <I>overflow</I> <I>-</I> you 
  used <B>unput()</B> to push back so much text that the scanner's buffer could 
  not hold both the pushed-back text and the current token in <B>yytext.</B> 
  Ideally the scanner should dynamically resize the buffer in this case, but at 
  present it does not. 
  <P><I>input buffer overflow, can't enlarge buffer because scanner uses REJECT 
  - </I>the scanner was working on matching an extremely large token and needed 
  to expand the input buffer. This doesn't work with scanners that use 
  <B>REJECT. </B>
  <P><I>fatal flex scanner internal error--end of buffer missed - </I>This can 
  occur in an scanner which is reentered after a long-jump has jumped out (or 
  over) the scanner's activation frame. Before reentering the scanner, use: <PRE>
<P><BR>    yyrestart( yyin );
<BR>
<P><BR></P></PRE>or, as noted above, switch to using the C++ scanner class. 
  <P><I>too</I> <I>many</I> <I>start</I> <I>conditions</I> <I>in</I> 
  <I>&lt;&gt;</I> <I>construct!</I> <I>-</I> you listed more start conditions in 
  a &lt;&gt; construct than exist (so you must have listed at least one of them 
  twice). </P></UL>
<H2>FILES </H2>
<UL>
  <P>
  <DL compact>
    <DT><B>-lfl</B> 
    <DD>library with which scanners must be linked. 
    <DT><I>lex.yy.c</I> 
    <DD>generated scanner (called <I>lexyy.c</I> on some systems). 
    <DT><I>lex.yy.cc</I> 
    <DD>generated C++ scanner class, when using <B>-+.</B> 
    <DT><I>&lt;FlexLexer.h&gt;</I> 
    <DD>header file defining the C++ scanner base class, <B>FlexLexer,</B> and 
    its derived class, <B>yyFlexLexer.</B> 
    <DT><I>flex.skl</I> 
    <DD>skeleton scanner. This file is only used when building flex, not when 
    flex executes. 
    <DT><I>lex.backup</I> 
    <DD>backing-up information for <B>-b</B> flag (called <I>lex.bck</I> on some 
    systems). </DD></DL></UL>
<H2>DEFICIENCIES / BUGS </H2>
<UL>
  <P>Some trailing context patterns cannot be properly matched and generate 
  warning messages ("dangerous trailing context"). These are patterns where the 
  ending of the first part of the rule matches the beginning of the second part, 
  such as "zx*/xy*", where the 'x*' matches the 'x' at the beginning of the 
  trailing context. (Note that the POSIX draft states that the text matched by 
  such patterns is undefined.) 
  <P>For some trailing context rules, parts which are actually fixed-length are 
  not recognized as such, leading to the abovementioned performance loss. In 
  particular, parts using '|' or {n} (such as "foo{3}") are always considered 
  variable-length. 
  <P>Combining trailing context with the special '|' action can result in 
  <I>fixed</I> trailing context being turned into the more expensive 
  <I>variable</I> trailing context. For example, in the following: <PRE>
<P><BR>    %%
<BR>    abc      |
<BR>    xyz/def
<BR>
<P><BR></P></PRE>
  <P>Use of <B>unput()</B> invalidates yytext and yyleng, unless the 
  <B>%array</B> directive or the <B>-l</B> option has been used. 
  <P>Pattern-matching of NUL's is substantially slower than matching other 
  characters. 
  <P>Dynamic resizing of the input buffer is slow, as it entails rescanning all 
  the text matched so far by the current (generally huge) token. 
  <P>Due to both buffering of input and read-ahead, you cannot intermix calls to 
  &lt;stdio.h&gt; routines, such as, for example, <B>getchar(),</B> with 
  <I>flex</I> rules and expect it to work. Call <B>input()</B> instead. 
  <P>The total table entries listed by the <B>-v</B> flag excludes the number of 
  table entries needed to determine what rule has been matched. The number of 
  entries is equal to the number of DFA states if the scanner does not use 
  <B>REJECT,</B> and somewhat greater than the number of states if it does. 
  <P><B>REJECT</B> cannot be used with the <B>-f</B> or <B>-F</B> options. 
  <P>The <I>flex</I> internal algorithms need documentation. </P></UL>
<H2>SEE ALSO </H2>
<UL>
  <P>lex(1), yacc(1), sed(1), awk(1). 
  <P>John Levine, Tony Mason, and Doug Brown, <I>Lex</I> <I>&amp;</I> 
  <I>Yacc,</I> O'Reilly and Associates. Be sure to get the 2nd edition. 
  <P>M. E. Lesk and E. Schmidt, <I>LEX</I> <I>-</I> <I>Lexical</I> 
  <I>Analyzer</I> <I>Generator</I> 
  <P>Alfred Aho, Ravi Sethi and Jeffrey Ullman, <I>Compilers:</I> 
  <I>Principles,</I> <I>Techniques</I> <I>and</I> <I>Tools,</I> Addison-Wesley 
  (1986). Describes the pattern-matching techniques used by <I>flex</I> 
  (deterministic finite automata). </P></UL>
<H2>AUTHOR </H2>
<UL>Vern Paxson, with the help of many ideas and much inspiration from Van 
  Jacobson. Original version by Jef Poskanzer. The fast table representation is 
  a partial implementation of a design done by Van Jacobson. The implementation 
  was done by Kevin Gong and Vern Paxson. 
  <P>Thanks to the many <I>flex</I> beta-testers, feedbackers, and contributors, 
  especially Francois Pinard, Casey Leedom, Stan Adermann, Terry Allen, David 
  Barker-Plummer, John Basrai, Nelson H.F. Beebe, benson@odi.com, Karl Berry, 
  Peter A. Bigot, Simon Blanchard, Keith Bostic, Frederic Brehm, Ian Brockbank, 
  Kin Cho, Nick Christopher, Brian Clapper, J.T. Conklin, Jason Coughlin, Bill 
  Cox, Nick Cropper, Dave Curtis, Scott David Daniels, Chris G. Demetriou, Theo 
  Deraadt, Mike Donahue, Chuck Doucette, Tom Epperly, Leo Eskin, Chris Faylor, 
  Chris Flatters, Jon Forrest, Joe Gayda, Kaveh R. Ghazi, Eric Goldman, 
  Christopher M. Gould, Ulrich Grepel, Peer Griebel, Jan Hajic, Charles 
  Hemphill, NORO Hideo, Jarkko Hietaniemi, Scott Hofmann, Jeff Honig, Dana 
  Hudes, Eric Hughes, John Interrante, Ceriel Jacobs, Michal Jaegermann, Sakari 
  Jalovaara, Jeffrey R. Jones, Henry Juengst, Klaus Kaempf, Jonathan I. Kamens, 
  Terrence O Kane, Amir Katz, ken@ken.hilco.com, Kevin B. Kenny, Steve Kirsch, 
  Winfried Koenig, Marq Kole, Ronald Lamprecht, Greg Lee, Rohan Lenard, Craig 
  Leres, John Levine, Steve Liddle, Mike Long, Mohamed el Lozy, Brian Madsen, 
  Malte, Joe Marshall, Bengt Martensson, Chris Metcalf, Luke Mewburn, Jim 
  Meyering, R. Alexander Milowski, Erik Naggum, G.T. Nicol, Landon Noll, James 
  Nordby, Marc Nozell, Richard Ohnemus, Karsten Pahnke, Sven Panne, Roland 
  Pesch, Walter Pelissero, Gaumond Pierre, Esmond Pitt, Jef Poskanzer, Joe 
  Rahmeh, Jarmo Raiha, Frederic Raimbault, Pat Rankin, Rick Richardson, Kevin 
  Rodgers, Kai Uwe Rommel, Jim Roskind, Alberto Santini, Andreas Scherer, 
  Darrell Schiebel, Raf Schietekat, Doug Schmidt, Philippe Schnoebelen, Andreas 
  Schwab, Alex Siegel, Eckehard Stolz, Jan-Erik Strvmquist, Mike Stump, Paul 
  Stuart, Dave Tallman, Ian Lance Taylor, Chris Thewalt, Richard M. Timoney, 
  Jodi Tsai, Paul Tuinenga, Gary Weik, Frank Whaley, Gerhard Wilhelms, Kent 
  Williams, Ken Yap, Ron Zellar, Nathan Zelle, David Zuhn, and those whose names 
  have slipped my marginal mail-archiving skills but whose contributions are 
  appreciated all the same. 
  <P>Thanks to Keith Bostic, Jon Forrest, Noah Friedman, John Gilmore, Craig 
  Leres, John Levine, Bob Mulcahy, G.T. Nicol, Francois Pinard, Rich Salz, and 
  Richard Stallman for help with various distribution headaches. 
  <P>Thanks to Esmond Pitt and Earle Horton for 8-bit character support; to 
  Benson Margulies and Fred Burke for C++ support; to Kent Williams and Tom 
  Epperly for C++ class support; to Ove Ewerlid for support of NUL's; and to 
  Eric Hughes for support of multiple buffers. 
  <P>This work was primarily done when I was with the Real Time Systems Group at 
  the Lawrence Berkeley Laboratory in Berkeley, CA. Many thanks to all there for 
  the support I received. 
  <P>Send comments to vern@ee.lbl.gov. </P></UL></BODY></HTML>
